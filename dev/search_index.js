var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference/API","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Auto generated docs for all exported functions and types.","category":"page"},{"location":"reference/#Types","page":"Reference/API","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:type]\nFilter = t -> !(t <: GeneralOrbital)\nPrivate = false","category":"page"},{"location":"reference/#Functions","page":"Reference/API","title":"Functions","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:function]\nPrivate = false","category":"page"},{"location":"reference/#SpinAdaptedSecondQuantization.E-Tuple{Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.E","text":"E(p, q)\n\nConstructs an expression containing a single excitation operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.act_on_ket-Tuple{O} where O<:SpinAdaptedSecondQuantization.Operator","page":"Reference/API","title":"SpinAdaptedSecondQuantization.act_on_ket","text":"act_on_ket(::Operator)\n\nAll typed extending Operator must overload this function. It should return the expression you end up with after acting the operator on a normal RHF ket.\n\nExample:\n\nE_p q HF = (2 δ_p q C(pOqO) + E_p q C(pVqO)) HF\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.delta-Tuple","page":"Reference/API","title":"SpinAdaptedSecondQuantization.delta","text":"delta(indices...)\n\nConstruct an expression consisting of a single Kronecker delta of the given indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.e-NTuple{4, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.e","text":"e(p, q, r, s) = E(p, q) * E(r, s) - δ(r, q) * E(p, s)\n\nAlias for the two electron singlet excitation operator. ```\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.δ-Tuple","page":"Reference/API","title":"SpinAdaptedSecondQuantization.δ","text":"δ(indices...)\n\nUnicode alias for delta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbitalSpaces","page":"Reference/API","title":"OrbitalSpaces","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:type]\nFilter = t -> t <: GeneralOrbital\nPrivate = false","category":"page"},{"location":"reference/#SpinAdaptedSecondQuantization.GeneralOrbital","page":"Reference/API","title":"SpinAdaptedSecondQuantization.GeneralOrbital","text":"GeneralOrbital\n\nTop level supertype of all orbital spaces. Any orbital subspace is a subtype of this type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SpinAdaptedSecondQuantization.OccupiedOrbital","page":"Reference/API","title":"SpinAdaptedSecondQuantization.OccupiedOrbital","text":"OccupiedOrbital\n\nType representing all occupied orbitals.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SpinAdaptedSecondQuantization.VirtualOrbital","page":"Reference/API","title":"SpinAdaptedSecondQuantization.VirtualOrbital","text":"VirtualOrbital\n\nType representing all virtual orbitals.\n\n\n\n\n\n","category":"type"},{"location":"#SpinAdaptedSecondQuantization.jl","page":"Home","title":"SpinAdaptedSecondQuantization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpinAdaptedSecondQuantization.jl is a Julia package for doing symbolic second quantization mainly targeted at quantum chemistry methods, such as post Hartree-Fock methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the package, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.8) pkg> add https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia version 1.8 or higher is required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can then be loaded","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpinAdaptedSecondQuantization","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpinAdaptedSecondQuantization","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n  using SpinAdaptedSecondQuantization\n  SASQ.disable_color()\nend","category":"page"},{"location":"#Basic-Structure","page":"Home","title":"Basic Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core type of the package is the Expression type. This contains an array of Term types. A term is a product that can contain a combination of various elements. These are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A scalar multiplier\nAn array of operators\nAn array of tensors\nAn array of Kronecker deltas\nAn array of summation indices\nA dictionary of orbital constraints","category":"page"},{"location":"#Orbital-Indices","page":"Home","title":"Orbital Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most types will contain orbital indices. For convenience these are represented as integers, but they are purely symbolic. When printed, they will be given names according to the semi-standard names for general molecular orbital (MO) indices pqrstuvw. This means that index 1 will be printed as 'p', 2 as 'q' and 8 as 'w'. For indices larger than 8 the names wrap around and are numbered with subscripts so index 9 will be printed as 'p₁' and index 78 as 'u₉'.","category":"page"},{"location":"#Operators","page":"Home","title":"Operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A small variety of operator types is supported, see (REF TO LIST) for full list.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A few examples are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2)\nE(1, 2) * E(3, 4)\ne(1, 2, 3, 4)\nfermion(1, α)\nfermiondag(2, β)","category":"page"},{"location":"#Tensors","page":"Home","title":"Tensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest tensor type is the RealTensor which has a name and an array of MO-indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"real_tensor(\"h\", 1, 2)\nreal_tensor(\"g\", 1, 2, 3, 4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some other types of tensors are supported with various symmetries in the indices. See (REF TO LIST) for full list.","category":"page"},{"location":"#Kronecker-Deltas","page":"Home","title":"Kronecker Deltas","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kronecker deltas constrain indices to be equal or else the term would be zero. They can have two or more indices each.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta(1, 2)\nδ(1, 2) # Unicode version equivalent to the one above\nd1 = δ(1, 2)\nd2 = δ(2, 3)\nd1 * d2 # Compacts delta expression since all are equal","category":"page"},{"location":"#Summation-Indices","page":"Home","title":"Summation Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A term can represent a sum over all values of a specific (or many) MO-indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = summation(E(1, 2), [1])\nb = ∑(E(1, 2), 1:2) # Unicode\na * b # Automatically renames summation indices to not collide","category":"page"},{"location":"#Orbital-Constraints","page":"Home","title":"Orbital Constraints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An important feature is the ability to tell a term whether an MO-index belongs to a particular subset of all orbitals, specifically whether it belongs to the occupied or virtual set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"occupied(1)\nvirtual(2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"here the constraints are printed explicitly as that is all that exists in the term, but if the index shows up other places in the term, the indices are colored to indicate the constraints instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = E(1, 2) * virtual(1) * occupied(2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where occupied orbitals are colored green and virtual are colored blue. If you would rather not have colored prints (printing to file, no color support in terminal, preferance, ...) you can easily turn this off:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SpinAdaptedSecondQuantization.disable_color()\na\nSASQ.enable_color() # Can use acronym SASQ instead of full module name\na","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constraints will transfer to other indices through Kronecker deltas and will produce a zero-term if they are unsatisfiable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = δ(1, 2) * occupied(1) # Now q is also occupied\nb = δ(2, 3) * virtual(3)\na * b # gives 0 as they cannot be occupied and virtual","category":"page"},{"location":"#Hartree-Fock-energy-expression","page":"Home","title":"Hartree-Fock energy expression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"h = ∑(rsym_tensor(\"h\", 1, 2) * E(1, 2), 1:2)\ng = simplify(∑(rsym_tensor(\"g\", 1:4...) * e(1:4...), 1:4))\nH = h + g\nE_hf = simplify_heavy(act_on_ket(H, 0))","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Auto generated docs for functions and types that are not exported. Mostly for development use.","category":"page"},{"location":"internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:type]\nPublic = false","category":"page"},{"location":"internals/#SpinAdaptedSecondQuantization.Constraints","page":"Internals","title":"SpinAdaptedSecondQuantization.Constraints","text":"Constraints = SortedDict{Int,Type}\n\nType alias for container of MO-Index constraints\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.KroneckerDelta","page":"Internals","title":"SpinAdaptedSecondQuantization.KroneckerDelta","text":"KroneckerDelta\n\nType representing a Kronecker delta of two or more MO-indices.\n\nnote: Note\nWhen constructing a KroneckerDelta it will return the integer 1 if the delta does not include two or more distinkt indices.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.Operator","text":"Operator\n\nAbstact operator type which all concrete operator types (i.e. Epq, a†p) must extend.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.SingletExcitationOperator","page":"Internals","title":"SpinAdaptedSecondQuantization.SingletExcitationOperator","text":"SingletExcitationOperator\n\nThe basic E_pq type operator.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Spin","page":"Internals","title":"SpinAdaptedSecondQuantization.Spin","text":"Spin\n\nEnum type to represent spin up (α) and down (β)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:function]\nPublic = false","category":"page"},{"location":"internals/#Base.:==-Union{Tuple{B}, Tuple{A}, Tuple{A, B}} where {A<:SpinAdaptedSecondQuantization.Operator, B<:SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"Base.:==","text":"Base.:==(::Operator, ::Operator)\n\nThis has to be explicitly implemented for each operator type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.isless-Union{Tuple{B}, Tuple{A}, Tuple{A, B}} where {A<:SpinAdaptedSecondQuantization.Operator, B<:SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"Base.isless","text":"Base.isless(::Operator, ::Operator)\n\nAll operator types must implement how they should be sorted among themselves (isless(::O, ::O)) and with respect to all other operator types that it is expected to be used together with (isless(::A, ::B)).\n\nThe implementation for how it sorts among the same operator type should be implemented in the definition file for that operator type.\n\nThe implementation for how the type sorts compared to other operator types should be added to the src/operators/sorting.jl file. These should be dummy routines that simply return true or false, and do not depend on the contents of the operators.\n\nnote: Note\nOnly one order needs to be implemented, meaning if isless(::A, ::B) is implemented, there is no need to also implement isless(::B, ::A)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.print-Union{Tuple{O}, Tuple{IO, DataStructures.SortedDict{Int64, Type}, O}} where O<:SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"Base.print","text":"Base.print(::IO, ::Constraints, ::Operator)\n\nAll typed extending Operator must overload this function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.compact_deltas-Tuple{Vector{SpinAdaptedSecondQuantization.KroneckerDelta}}","page":"Internals","title":"SpinAdaptedSecondQuantization.compact_deltas","text":"compact_deltas(deltas::Vector{KroneckerDelta})\n\nReturns a new reduced Vector{KroneckerDelta} where there exists only one delta per group of equal indices.\n\nExample:\n\nδ_pq δ_qr δ_st -> δ_pqr δst\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.disable_color-Tuple{}","page":"Internals","title":"SpinAdaptedSecondQuantization.disable_color","text":"disable_color()\n\nDisables the coloring of MO-indices to indicate orbital space constraints. This will make all constraints be printed explicitly which can make some terms a bit long to read. Color is enabled by default.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.enable_color-Tuple{}","page":"Internals","title":"SpinAdaptedSecondQuantization.enable_color","text":"enable_color()\n\nEnables the coloring of MO-indices to indicate orbital space constraints. Color is enabled by default. Currently the coloring scheme is given by:     GeneralOrbital: colorless     OccupiedOrbital: green     VirtualOrbital: blue\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.exchange_indices-Tuple{SpinAdaptedSecondQuantization.KroneckerDelta, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.exchange_indices","text":"exchange_indices(d::KroneckerDelta, mapping)\n\nReturns a new KroneckerDelta with indices exchanged according to the mapping\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.exchange_indices-Union{Tuple{O}, Tuple{O, Any}} where O<:SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.exchange_indices","text":"exchange_indices(::Operator, mapping)\n\nAll typed extending Operator must overload this function. It should return a new operator where all indices have been exchanged according to the mapping.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.get_all_indices-Tuple{O} where O<:SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.get_all_indices","text":"get_all_indices(::Operator)\n\nAll typed extending Operator must overload this function. It should return an iteratable over all the MO-indices contained in the operator in order.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.reductive_commutator-Tuple{SpinAdaptedSecondQuantization.Operator, SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"SpinAdaptedSecondQuantization.reductive_commutator","text":"reductive_commutator(::Operator, ::Operator)\n\nDefines how operators commute. This will act as either a commutator or anticommutator depending on which reduces the rank of the resulting operators.\n\nReturns a Tuple{Int,Expression} which gives the type of commutator used and the resulting expression. The type is signaled by returning 1 or -1 as the first element of the tuple. This represents the sign change by commutation which is 1 for a normal commutator (A B = 0  AB == BA) and -1 for an anticommutator (A B_+ = 0  AB = -BA)\n\nThis should be implemented for all pairs of operators types that are expected to show up in the same expression. The implementations should be put in the src/operators/commutation_relations.jl file.\n\nnote: Note\nOnly one order needs to be implemented, meaning if reductive_commutator(::A, ::B) is implemented, there is no need to also implement reductive_commutator(::B, ::A)\n\n\n\n\n\n","category":"method"}]
}
