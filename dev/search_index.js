var documenterSearchIndex = {"docs":
[{"location":"ccsd_example/#Coupled-Cluster-Singles-and-Doubles-Example","page":"CCSD example","title":"Coupled Cluster Singles and Doubles Example","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here is a detailed example of how to derive common expressions and equations for the closed shell CCSD method. This will also serve as a way of showcasing the various functionality of the package.","category":"page"},{"location":"ccsd_example/#Hamiltonian","page":"CCSD example","title":"Hamiltonian","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"For the hamiltonian we will use the familiar expression for the non-relativistic electronic hamiltonian, however we will express it in terms of the fock matrix instead of the normal one-electron matrix","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"F_pq = h_pq + sum_ileft(2 g_pqii - g_piiqright)","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"h_pq = F_pq - sum_ileft(2 g_pqii - g_piiqright)","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"This is because every expression except the HF energy looks simpler expressed in terms of the fock matrix. In code we then define the hamiltonian as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"using SpinAdaptedSecondQuantization\nh = ∑((\n        real_tensor(\"F\", 1, 2) +\n        ∑((-2 * psym_tensor(\"g\", 1, 2, 3, 3) +\n            psym_tensor(\"g\", 1, 3, 3, 2)) * occupied(3), [3])\n    ) * E(1, 2) * electron(1, 2), 1:2)\ng = 1//2 * simplify(\n    ∑(psym_tensor(\"g\", 1:4...) * e(1:4...) * electron(1:4...), 1:4)\n)\nH = h + g","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"We omit the nuclear repulsion term and we do not assume any symmetry in our integrals apart from the particle exchange symmetry in the two electron integrals. We do this since we can then use the T1 transformed integrals allowing us to ignore the T1 operator when deriving equations.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"We can derive the HF energy expression for the Hamiltonian in terms of the Fock matrix as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"E_HF = simplify_heavy(hf_expectation_value(H))","category":"page"},{"location":"ccsd_example/#Cluster-Operator","page":"CCSD example","title":"Cluster Operator","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"The cluster operator we define then as only the T2 operator as the T1 amplitudes are included in the T1 transformed integrals.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"T2 = 1//2 * ∑(psym_tensor(\"t\", 1:4...) * E(1, 2) * E(3, 4) *\noccupied(2, 4) * virtual(1, 3), 1:4)","category":"page"},{"location":"ccsd_example/#Similrarity-transformed-Hamiltonian","page":"CCSD example","title":"Similrarity transformed Hamiltonian","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"A central operator in coupled cluster theory is the similarity transformed Hamiltonian operator","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"bar H = e^-T H e^T","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"This is usually computed using the Baker-Campbell-Hausdorff (BCH) expansion","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"e^-B A e^B = A + A B + frac12 A B B + frac13 A B B + ","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"A nice feature of this expansion for the electronic hamiltionian and the cluster operator is that it truncates after the 4th order term (5 terms). This is because the 5th order expression is zero","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"H E_ai E_bj E_ck E_dl E_em = 0","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"This means that we can explicitly compute the full similarity transformed Hamiltonian with no fear of missing any terms. We supply the function bch(A, B, n) which computes the BCH expansion to nth order.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"note: Note\nWe also supply the functon bch(A, [B1, B2, ...], n) which is equivalent to bch(A, B1 + B2 + ..., n) when all of B1, B2, ... comute among each other, but is much faster as it avoids computing equivalent terms such as A B_1 B_2 and A B_2 B_1. This can be especially useful for higher order coupled cluster methods such as CCSDT and beyond, as well as exotic methods such as QED-CC and NEO-CC.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"In code this looks like","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Hbar = simplify(bch(H, T2, 4)); # Avoid printing as this is quite long","category":"page"},{"location":"ccsd_example/#Ground-State-Energy-Expression-and-Equations","page":"CCSD example","title":"Ground State Energy Expression and Equations","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"The coupled cluster ground state energy and equations are obtained by projecting the similarity constrained Schrödinger equation","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"bar H textHFrangle = E textHFrangle","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"onto a set of bra states. The energy is obtained by projecting on the HF bra","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"E_0 = langletextHF bar H textHFrangle","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"while the coupled cluster wave function is determined by projecting on a set of excited bra states determined from the cluster operator","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"langlemu bar H textHFrangle = 0","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"In both cases we require the quantity bar H textHFrangle which we can explicitly compute by the function act_on_ket(ex, [max_ops]).","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Hbar_ket = simplify(act_on_ket(Hbar, 2)); # Avoid printing long expression","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here we choose to throw away any terms with more than two operators as in CCSD we are never projecting on any bra that is more than doubly excited. This can speed up the projection and further operations by a bit.","category":"page"},{"location":"ccsd_example/#Energy","page":"CCSD example","title":"Energy","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"To obtain the energy expression we project the Hbarket on HF from the left. This can be nicely done using the `actonbra(ex, [maxops])` function","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"E0 = simplify_heavy(act_on_bra(Hbar_ket))","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Since the interesting part here is that which differs from HF, we can get the correlation energy as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"E_corr = E0 - E_HF","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here we see a very common pattern; the 2 * coulomb - 1 * exchange pattern where we have terms that differ by a prefactor of -frac12 and an exchange of index 2 and 4 of a 4 index tensor, such as the two electron integrals or the T2 amplitudes. We usually define separate tensor names for these patterns  such as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"L_pqrs = 2 g_pqrs - g_psrq","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"and","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"u_aibj = 2 t_aibj - t_ajbi","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"We provide a pair of functions to look for this pattern in expressions. firstly and mainly look_for_tensor_replacements function which is the actual engine that takes an expression and a tensor transformation function and looks for terms that are equal up to this transformation. We provide the utility function make_exchange_transformer which produces a transformer that looks for the 2 * coulomb - 1 * exchange pattern. We can show this in action on the correlation energy looking for both the patterns mentioned above","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"look_for_tensor_replacements(E_corr, make_exchange_transformer(\"g\", \"L\"))\nlook_for_tensor_replacements(E_corr, make_exchange_transformer(\"t\", \"u\"))","category":"page"},{"location":"ccsd_example/#Omega-Equations","page":"CCSD example","title":"Omega Equations","text":"","category":"section"},{"location":"ccsd_example/#Biorthogonal-Bra","page":"CCSD example","title":"Biorthogonal Bra","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"For the singles equations we want to compute quantity","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Omega_i^a = barleftlangle_i^aright bar H textHFrangle","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"where the bra barleftlangle_i^aright is the biorthogonal bra state for the singly excited determinant","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"left_i^arightrangle = E_ai textHFrangle","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"defined such that","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"leftlanglebar_i^a_j^brightrangle = delta_ij delta_ab","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"For a singly excited determinant we can explicitly express this biorthogonal bra simply as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"barleftlangle_i^aright = frac12 langletextHF E_ia","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"As a quick example we can show this","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"bra = 1//2 * E(2, 1) * occupied(2) * virtual(1)\nket = E(3, 4) * occupied(4) * virtual(3)\nhf_expectation_value(bra * ket)","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"However for higher excitations the biorthogonal bra states can not be as easily expressed explicitly. For doubly excited determinants we want a biorthornormal bra state barleftlangle_ij^abright such that","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"leftlanglebar_ij^ab_kl^cdrightrangle = P_aibj delta_ik delta_jl delta_ac delta_bd = delta_ik delta_jl delta_ac delta_bd + delta_jk delta_il delta_bc delta_ad","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"with the permutation operator P_aibj generating the equivalent permutations due to the particle symmetry in the doubly excited determinant","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"left_ij^abrightrangle = left_ji^barightrangle = E_ai E_bj textHFrangle = E_bj E_ai textHFrangle","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"We can write the biorthogonal bra explicitly as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"barleftlangle_ij^abright = frac13 leftlangle_ij^abright + frac16 leftlangle_ji^abright = langletextHF left(     frac13 E_jb E_ia +     frac16 E_ib E_ja right)","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Which we can confirm using the code","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"bra = (1//3 * E(4, 3) * E(2, 1) + 1//6 * E(2, 3) * E(4, 1)) *\n    occupied(2, 4) * virtual(1, 3)\nket = E(5, 6) * E(7, 8) * occupied(6, 8) * virtual(5, 7)\nhf_expectation_value(bra * ket)","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"note: Note\nFor higher order excited determinants such as triples, quadruples, etc. it is, however, not possible to explicitly express a biorthogonal state that has the desired properties. This is related to the fact that the expression is zeroP^abc E_ai E_bj E_ck = 0It is, however, still useful to be able to derive the expressions you would get if you project on a biorthogonal basis anyway, even if it is not expressible as a linear combination of excited determinants. For the triples for example, we can define two distinct expressionsOmega_ijk^abc = leftlanglebar_ijk^abcright bar H textHFrangletilde Omega_ijk^abc = leftlangle_ijk^abcright bar H textHFranglethe latter of which is the quantity that \"actually exists\" as a projection onto a set of bra states which are expressible as excited determinants and represent the equations which are to be solved to obtain the coupled cluster wave function. The two Omega expressions are related by a non invertible linear transformationtilde Omega_ijk^abc = sum_aibjck     S_ijkijk^abcabc     Omega_ijk^abc We can then see that if one finds amplitudes such that the Omega found by using the biorthogonal states they will also make the tilde Omega be zero, which is the condition we want to solve for. This is nice as we can safely \"pretend\" there exists a biorthogonal basis which produces much simpler expressions and are therefore more efficient to derive and numerically compute.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Since we do not want to (and often can not, see note above) make an explicit expression for a biorthogonal bra we provide the function project_biorthogonal which lets us insert Kronecker deltas according to the definition of the biorthogonality in addition to the symmetrize function to expand the permutations required by the biorthogonality. We can reproduce the same behaviour as for the biorthogonal doubles from above as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"ket = E(5, 6) * E(7, 8) * occupied(6, 8) * virtual(5, 7)\nproject_biorthogonal(ket, E(1, 2) * E(3, 4))\nsymmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]))","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here we supplied the \"template\" ket E(1, 2) * E(3, 4) which is that we want to project on the biorthogonal bra of.","category":"page"},{"location":"ccsd_example/#Singles-Equations","page":"CCSD example","title":"Singles Equations","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"We can use the project_biorthogonal function to project Hbar_ket on the singles biorthogonal bra and get an expression for Omega_i^a","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"omega_ai = project_biorthogonal(Hbar_ket, E(1, 2))","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here we also see the 2 * coulomb - 1 * exchange pattern show up again, so we can simplify by.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"omega_ai = look_for_tensor_replacements(omega_ai,\n    make_exchange_transformer(\"t\", \"u\"))","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Which produces a nice simplified expression for the singes part of the CCSD equations.","category":"page"},{"location":"ccsd_example/#Doubles-Equations","page":"CCSD example","title":"Doubles Equations","text":"","category":"section"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here we want to derive the expression for the doubles Omega","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Omega_ij^ab = barleftlangle_ij^abright bar H textHFrangle","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Just like for the singles equations we project on a biorthogonal bra, though now using a doubly excited ket as the template, and we need to symmetrize to include the pertmutations caused by the particle symmetry of the biorthogonal bra.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"project_biorthogonal(Hbar_ket, E(1, 2) * E(3, 4));\nomega_aibj = simplify_heavy(\n    symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)])));\nomega_aibj_u = look_for_tensor_replacements(omega_aibj,\n    make_exchange_transformer(\"t\", \"u\"))","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Here we needed to use the (sometimes) expensive simplify_heavy function to fully simplify, as well as recognizing the 2 * coulomb - 1 * exchange pattern for the T2 amplitudes. Now we have a correct and rather nice expression for the doubles equations, however, because of the particle symmetry of the bra that we introduced with the call to symmetrize some terms are equal after permuting the indices (a, i) <-> (b, j). Computing all of these redundant terms leads to a lot of unnecessary terms to code and compute, so it is much more efficient to only code the non-redundant ones, then symmetrize the final result numerically. To help with this, we provide the desymmetrize function which sort of acts like the reverse of symmetrize. We can call this function on our Omega_ij^ab expression","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"omega_aibj_r, omega_aibj_ss, omega_aibj_ns = desymmetrize(\n    omega_aibj_u, make_permutation_mappings([(1, 2), (3, 4)])\n);\nomega_aibj_r\nomega_aibj_ss\nomega_aibj_ns","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"The desymmetrize function returns three expressions. The first omega_aibj_r contains the terms it found redundant permutations of elsewhere in the original expression. These needs to be symmetrized to obtain the correct expression. The second term omega_aibj_ss contains the \"self-symmetric\" terms. These are the terms which themselves carry the symmetry requested and can be evaluated as-is. The third and last term omega_aibj_ns are the \"non-symmetric\" terms. Interestingly, we have here gotten two terms in the non-symmetric expression, even though the result should be symmetric. Under closer inspection one can see that the two \"non-symmetric\" terms are indeed symmetric if one re-expands the u_aidk tensor in terms of t. To avoid having non-symmetric terms we can instead directly desymmetrize the omega before looking for coulomb - exchange symmetry.","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"omega_aibj_r, omega_aibj_ss, omega_aibj_ns = desymmetrize(\n    omega_aibj, make_permutation_mappings([(1, 2), (3, 4)])\n);\nlook_for_tensor_replacements(omega_aibj_r, make_exchange_transformer(\"g\", \"L\"))\nlook_for_tensor_replacements(omega_aibj_ss, make_exchange_transformer(\"g\", \"L\"))\nomega_aibj_ns","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"where we see that the non-symmetric part is indeed zero, but we have lost the ability to remove all prefactors. Counting total terms we can see that both strategies give 15 terms in total, so the cost should not be much different, but it can be nice to keep in mind. In any case to evaluate the full doubles omega one needs to symmetrize the redundant expression, and add the direct evaluation of the self-symmetric and apparent non-symmetric expression which we can write as","category":"page"},{"location":"ccsd_example/","page":"CCSD example","title":"CCSD example","text":"Omega_ij^ab = (Omega_textss)_ij^ab + (Omega_textns)_ij^ab + P_ij^ab (Omega_texts)_ij^ab","category":"page"},{"location":"reference/#Reference/API","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Auto generated docs for all exported functions and types.","category":"page"},{"location":"reference/#Types","page":"Reference/API","title":"Types","text":"","category":"section"},{"location":"reference/#Functions","page":"Reference/API","title":"Functions","text":"","category":"section"},{"location":"reference/#SpinAdaptedSecondQuantization.E-Tuple{Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.E","text":"E(p, q)\n\nConstructs an expression containing a single excitation operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.act_eT_on_bra-Tuple{Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.act_eT_on_bra","text":"act_eT_on_bra(braop::Expression, T::Expression; [max_n=Inf], [max_ops=Inf])\n\ncomputes\n\nlangletextHF textbraop e^T\n\nThis can be useful for evaluating certain coupled cluster expressions from left to right. Since the cluster operator T is purely exciting acting e^T to the left will terminate after only a few terms depending on the left state being projected on.\n\nwarning: Warning\nIf T contains de-excitations, the expression will not truncate and the parameter max_n must be specified with a finite positive integer for the function to terminate, truncating the expression. max_n specifies the highest order term from the taylor expansion of e^T to include. If T is purely exciting, the expansion exits early when it terminates.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.act_on_bra","page":"Reference/API","title":"SpinAdaptedSecondQuantization.act_on_bra","text":"act_on_bra(x::Expression, [max_ops=Inf])\n\nProjects x on a HF bra by projecting the adjoint on a ket and ajointing the result.\n\nact_on_bra(x, max_ops=Inf) = act_on_ket(x', max_ops)'\n\nSee act_on_ket\n\n\n\n\n\n","category":"function"},{"location":"reference/#SpinAdaptedSecondQuantization.act_on_ket-Tuple{SpinAdaptedSecondQuantization.Operator}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.act_on_ket","text":"act_on_ket(::Operator)\n\nAll typed extending Operator must overload this function. It should return the expression you end up with after acting the operator on a normal RHF ket.\n\nExample:\n\nE_p q textHF = left(2 δ_p q C(pOqO) + E_p q C(pVqO)right) textHF\n\nWhich we can also do in code:\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> E(1, 2) * electron(1, 2)\nE_pq\njulia> ket = act_on_ket(ans)\nE_ai\n+ 2 δ_ij\njulia> disable_external_index_translation()\n\njulia> ket\nE_₁₂ C(₁∈v, ₂∈o)\n+ 2 δ_₁₂ C(₁∈o, ₂∈o)\njulia> enable_external_index_translation()\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.act_on_ket-Union{Tuple{SpinAdaptedSecondQuantization.Expression{T}}, Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T","page":"Reference/API","title":"SpinAdaptedSecondQuantization.act_on_ket","text":"act_on_ket(ex::Expression, [max_ops=Inf])\n\nProject ex onto a textHFrangle ket to the right. This is done termwise and for each term the folliwing recursive formula is used to project an arbitrary string of operators on a ket.\n\nThe base case is that there is an implementation of act_on_ket(o) for each operator type in the string such that we have\n\nA_i textHFrangle = tilde A_i textHFrangle\n\nwhere tilde A_i is constrained and simplified from the projection. The recursive step is then\n\nA_1 A_2  A_n textHFrangle = A_1 A_2  tilde A_n textHFrangle = A_1 A_2  tilde A_n_Gamma textHFrangle + Gamma tilde A_n (A_1 A_2  A_n-1) textHFrangle\n\nwhere the A B_Gamma notation is the reductive_commutator which chooses whether to compute a commutatior or anticommutator depending on the input to reduce the number of operator in the output.\n\nThe optional parameter max_ops specifies the maximum number of operator to keep in any terms. If only a few excitations are needed, specifying this can greatly speed up the projection.\n\nExample\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> E(1, 2) * E(3, 4) * electron(1:4...)\nE_pq E_rs\njulia> ket = simplify(act_on_ket(ans))\nE_ai E_bj\n+ 2 δ_ij E_ak\n- δ_ik E_aj\n+ δ_bc E_ai\n+ 2 δ_jk E_ai\n+ 4 δ_ij δ_kl\n+ 2 δ_ij δ_ab\njulia> disable_external_index_translation()\n\njulia> ket\nE_₁₂ E_₃₄ C(₁∈v, ₂∈o, ₃∈v, ₄∈o)\n+ 2 δ_₁₂ E_₃₄ C(₁∈o, ₂∈o, ₃∈v, ₄∈o)\n- δ_₁₄ E_₃₂ C(₁∈o, ₂∈o, ₃∈v, ₄∈o)\n+ δ_₂₃ E_₁₄ C(₁∈v, ₂∈v, ₃∈v, ₄∈o)\n+ 2 δ_₃₄ E_₁₂ C(₁∈v, ₂∈o, ₃∈o, ₄∈o)\n+ 4 δ_₁₂ δ_₃₄ C(₁∈o, ₂∈o, ₃∈o, ₄∈o)\n+ 2 δ_₁₄ δ_₂₃ C(₁∈o, ₂∈v, ₃∈v, ₄∈o)\njulia> enable_external_index_translation()\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.anticommutator-Union{Tuple{B}, Tuple{A}, Tuple{SpinAdaptedSecondQuantization.Expression{A}, SpinAdaptedSecondQuantization.Expression{B}}} where {A<:Number, B<:Number}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.anticommutator","text":"anticommutator(a::Expression, b::Expression)\n\nCompute commutator between a and b. This is computed termwise using the reductive_commutator function, then adding/subtracting the swapped result if the reductive commutator for a given pair of terms turned out to be an commutator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.bch-Tuple{Any, AbstractArray, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.bch","text":"bch(A, Bs::AbstractArray, n)\n\nEquivalent to bch(A, sum(Bs), n) if all Bs commute with eachother, but evalutating in a smart way in order to avoid computing equivalent terms many times, for example instead of computing both rac12 A B_1 B_2 and rac12 A B_2 B_1, it will only compute the first one and multiply by 2. This can be much faster if one has many commuting terms in Bs.\n\nwarning: Warning\nShould not be used if some expressions in Bs do not commute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.bch-Tuple{Any, SpinAdaptedSecondQuantization.Expression, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.bch","text":"bch(A, B, n)\n\nCompute Baker-Campbell-Haussdorff expansion\n\ne^-B A e^B = A + A B + frac12 A B B + frac13 A B B B + frac1n A B B B B\n\nup to nth order. Terminates if commutator becomes zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.commutator-Tuple{Any, Any, Vararg{Any}}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.commutator","text":"commutator(A, B, C, ...)\n\nComputes the nested commutator A B C \n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.commutator-Tuple{SpinAdaptedSecondQuantization.Expression, SpinAdaptedSecondQuantization.Expression, Integer}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.commutator","text":"commutator(A::Expression, B::Expression, n::Integer)\n\nCompute n nested commutators A B B B.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.commutator-Union{Tuple{B}, Tuple{A}, Tuple{SpinAdaptedSecondQuantization.Expression{A}, SpinAdaptedSecondQuantization.Expression{B}}} where {A<:Number, B<:Number}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.commutator","text":"commutator(a::Expression, b::Expression)\n\nCompute commutator between a and b. This is computed termwise using the reductive_commutator function, then adding/subtracting the swapped result if the reductive commutator for a given pair of terms turned out to be an anti-commutator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.convert_to_elementary_operators-Union{Tuple{SpinAdaptedSecondQuantization.Expression{T}}, Tuple{T}} where T<:Number","page":"Reference/API","title":"SpinAdaptedSecondQuantization.convert_to_elementary_operators","text":"convert_to_elementary_operators(ex::Expression)\n\nconverts all operators to their representation using \"elementary\" annihilation and creation operators if implemented for all operator types in ex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.delta-Tuple","page":"Reference/API","title":"SpinAdaptedSecondQuantization.delta","text":"delta(indices...)\n\nConstruct an expression consisting of a single Kronecker delta of the given indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T<:Number","page":"Reference/API","title":"SpinAdaptedSecondQuantization.desymmetrize","text":"desymmetrize(ex::Expression, mappings)\n\nFunction to look for terms which are equal under the index permutations given by the mappings. See symmetrize and make_permutation_mappings.\n\nReturns three expressions:\n\nThe first expression contains the terms where redundant copies were found  which are equal under the given symmetry. These needs to be symmetrized  to obtain the original expression, usally after numerically evaluating  the non-redundant terms.\nThe second expression constins the \"self-symmetric\" terms, which on their own  are invariant under the given symmetries and do not need to be symmetrized.\nThe last expression contains any left over \"non-symmetric\" terms. This is  expected to be zero when desymmetrizing an expression with a known symmetry  such as CCSD omega equations.\n\nExamples\n\nSetting up an example expression:\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> ∑(real_tensor(\"F\", 1, 5) * psym_tensor(\"t\", 3, 4, 5, 2) * occupied(2, 4) * virtual(1, 3, 5), [5])\n∑_c(F_ac t_bjci)\njulia> symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]))\n∑_c(F_ac t_bjci)\n+ ∑_c(F_bc t_aicj)\njulia> ans + ∑(psym_tensor(\"g\", 1, 5, 3, 6) * psym_tensor(\"t\", 5, 2, 6, 4) * occupied(2, 4) * virtual(1, 3, 5, 6), 5:6)\n∑_c(F_ac t_bjci)\n+ ∑_c(F_bc t_aicj)\n+ ∑_cd(g_acbd t_cidj)\njulia> ans + real_tensor(\"x\", 1, 2, 3, 4) * occupied(2, 4) * virtual(1, 3)\nx_aibj\n+ ∑_c(F_ac t_bjci)\n+ ∑_c(F_bc t_aicj)\n+ ∑_cd(g_acbd t_cidj)\n\nDesymmetrizing:\n\njulia> r, ss, ns = desymmetrize(ans * 1//1, make_permutation_mappings([(1, 2), (3, 4)]));\n\njulia> r # Only one of the two redundant terms survives\n∑_c(F_ac t_bjci)\njulia> ss # The self-symmetric term\n∑_cd(g_acbd t_cidj)\njulia> ns # The non-symmetric term\nx_aibj\n\nwarning: Warning\ndesymmetrize does repeated calls to simplify_heavy which can be slow if terms have many (>=8) summation indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.disable_color-Tuple{Int64}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.disable_color","text":"disable_color(s)\n\nDisables the coloring for index space s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.disable_external_index_translation-Tuple{}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.disable_external_index_translation","text":"disable_external_index_translation()\n\nDisables external indices to be printed with names according to their constraints. This can be useful as a debugging tool when dealing with terms with different constraints on external indices in the same expression.\n\nSee enable_external_index_translation for example.\n\nEnabled by default. Re-enable using enable_external_index_translation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.disable_internal_index_translation-Tuple{}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.disable_internal_index_translation","text":"disable_internal_index_translation()\n\nDisables internal indices to be printed with names according to their constraints. This can be useful as a debugging tool if summation indices are getting reordered/changed in weird ways.\n\nSee enable_internal_index_translation for example.\n\nEnabled by default. Re-enable using enable_internal_index_translation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.e-NTuple{4, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.e","text":"e(p, q, r, s) = E(p, q) * E(r, s) - δ(r, q) * E(p, s)\n\nAlias for the two electron singlet excitation operator. ```\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.enable_external_index_translation-Tuple{}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.enable_external_index_translation","text":"enable_external_index_translation()\n\nEnables external indices to be printed with names according to their constraints.\n\nwarning: Warning\nThis can cause some confusion when different terms in the same expression contains different index constraints, as this will cause the same index to be printed with different names.julia> using SpinAdaptedSecondQuantization\n\njulia> ex = E(1, 2) * occupied(1, 2) + E(1, 2) * virtual(1, 2)\nE_ab\n+ E_ij\njulia> disable_external_index_translation()\n\njulia> ex # Now it is clearer that they are the same indices\nE_₁₂ C(₁∈v, ₂∈v)\n+ E_₁₂ C(₁∈o, ₂∈o)\njulia> enable_external_index_translation()\n\njulia> ex # back to default behavour\nE_ab\n+ E_ij\n\nEnabled by default. Disabled using disable_external_index_translation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.enable_internal_index_translation-Tuple{}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.enable_internal_index_translation","text":"enable_internal_index_translation()\n\nEnables internal indices to be printed with names according to their constraints.\n\nExample\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> ex = ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), 1:2)\n∑_pq(h_pq E_pq)\njulia> disable_internal_index_translation()\n\njulia> ex\n∑_₁₂(h_₁₂ E_₁₂) C(₁∈g, ₂∈g)\njulia> ex *= E(1, 2) * occupied(2) * virtual(1) # Indices shifted up\n∑_₃₄(h_₃₄ E_₃₄ E_ai) C(₃∈g, ₄∈g)\njulia> enable_internal_index_translation()\n\njulia> ex # Shift in indices is invisible when translated\n∑_pq(h_pq E_pq E_ai)\n\nEnabled by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.hf_expectation_value-Tuple{SpinAdaptedSecondQuantization.Expression}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.hf_expectation_value","text":"hf_expectation_value(ex::Expression) = act_on_ket(ex, 0)\n\nAlias for calling act_on_ket keeping no operators, which gives the HF expectation value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.look_for_tensor_replacements-Tuple{SpinAdaptedSecondQuantization.Expression, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.look_for_tensor_replacements","text":"look_for_tensor_replacements(ex::Expression, transformer)\n\nLooks for pairs of terms in ex that are equal up to a tensor transformation given by transformer. The most common use case is to recognize patterns such as L_pqrs = 2 g_pqrs - g_psrq where a convencience function to produce the relevant transformer provided (see make_exchange_transformer).\n\nDocTestSetup = quote\n    using SpinAdaptedSecondQuantization\n    h = ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), 1:2)\n    g = 1//2 * simplify(\n        ∑(psym_tensor(\"g\", 1:4...) * e(1:4...) * electron(1:4...), 1:4)\n    )\n    H = h + g + real_tensor(\"h_nuc\")\nend\n\njulia> E_HF = simplify_heavy(hf_expectation_value(H))\nh_nuc\n+ 2 ∑_i(h_ii)\n+ 2 ∑_ij(g_iijj)\n- ∑_ij(g_ijji)\njulia> look_for_tensor_replacements(E_HF, make_exchange_transformer(\"g\", \"L\"))\nh_nuc\n+ 2 ∑_i(h_ii)\n+ ∑_ij(L_iijj)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.make_exchange_transformer-Tuple{Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.make_exchange_transformer","text":"make_exchange_transformer(name_from, name_to)\n\nConvenience function to make tensor transformer for use in look_for_tensor_replacements.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.make_permutation_mappings-Tuple{Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.make_permutation_mappings","text":"make_permutation_mappings(index_groups)\n\nConvenience function to make mapping for all permutations of groups of indices. See symmetrize and desymmetrize.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.print_code-Tuple{SpinAdaptedSecondQuantization.Term, String, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.print_code","text":"Print term to numpy's einsum routine\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.print_eT_code-Tuple{SpinAdaptedSecondQuantization.Term, Any, Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.print_eT_code","text":"Used with https://github.com/alexancp/einsumpath-to-eT to generate Fortran subroutines for eT.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.print_eT_function_generator","page":"Reference/API","title":"SpinAdaptedSecondQuantization.print_eT_function_generator","text":"printeTfunctiongenerator(name, ex, symbol, indices, translation,                     [wftype], [tensortranslation], [noinputtensors], [outperms])\n\n\n\n\n\n","category":"function"},{"location":"reference/#SpinAdaptedSecondQuantization.print_julia_function","page":"Reference/API","title":"SpinAdaptedSecondQuantization.print_julia_function","text":"printjuliafunction(name, ex, symbol, indices, translation,                     [tensortranslation], [explicittensor_blocks])\n\n\n\n\n\n","category":"function"},{"location":"reference/#SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T<:Number","page":"Reference/API","title":"SpinAdaptedSecondQuantization.project_biorthogonal","text":"project_biorthogonal(ex::Expression, template::Expression)\n\nThis has the effect of projecting the expression ex on the biorthogonal bra state of the template expression.\n\nFor a singlet double excitation, the following will be equivalent:\n\nbra = (\n        1//3 * E(1, 2) * E(3, 4) +\n        1//6 * E(1, 4) * E(3, 2)\n    )' * occupied(2, 4) * virtual(1, 3)\n\nresult = hf_expectation_value(bra * ex)\n\nket = E(1, 2) * E(3, 4) * occupied(2, 4) * virtual(1, 3)\nresult = project_biorthogonal(act_on_ket(ex), ket)\nresult = symmetrize(result, make_permutation_mappings([(1, 2), (3, 4)]))\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.set_color-Tuple{Int64, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.set_color","text":"set_color(s, color)\n\nSets the color of a index space s to the specified color. Allowed colors are given by the Base.text_colors dict. This includes integers in the range 0-255 which the corresponding colors can be found in this table on Wikipedia.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.simplify-Tuple{SpinAdaptedSecondQuantization.Expression}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.simplify","text":"simplify(ex::Expression)\n\nApplies various simplification strategies to the given expression. The most important are:\n\nRemove Kronecker deltas when indices are summed over.\nPerform various operations to try to lower the lexiographic ordering of the   each term including:\nLowering indices showing up in a Kronecker delta to the lowest of the   indices in said delta.\nLowering summation indices to lowest available indices.\nReorder summation indices to lower the lexiographic ordering of the order   they show up within the term.\nBubble sort operators swaping neighbouring operators if:\nThey commute\nThe swap would lower the terms lexiographic ordering.\nLook for pairs of terms differing only in index constraints and scalar   prefactors, and tries to combine them.\n\nExamples:\n\nCollapsing deltas:\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> ∑(real_tensor(\"h\", 1, 2) * electron(1, 2) * δ(1, 2), [2])\n∑_q(δ_pq h_pq)\njulia> simplify(ans)\nh_pp\n\nCombining terms differing only by index constraints and scalars:\n\njulia> real_tensor(\"h\", 1, 2) * (occupied(1, 2) + occupied(1) * virtual(2))\nh_ia\n+ h_ij\njulia> simplify(ans)\nh_ip\n\njulia> ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), [1, 2])\n∑_pq(h_pq E_pq)\njulia> ans - ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1) * occupied(2), [1, 2])\n∑_pq(h_pq E_pq)\n- ∑_pi(h_pi E_pi)\njulia> simplify(ans)\n∑_pa(h_pa E_pa)\n\nSorting commuting operators:\n\njulia> E(3, 4) * E(1, 2) * electron(1:4...)\nE_rs E_pq\njulia> simplify(ans) # not able to swap as commutator is not zero\nE_rs E_pq\njulia> ans * occupied(2, 4) * virtual(1, 3)\nE_bj E_ai\njulia> simplify(ans) # now able to swap\nE_ai E_bj\n\njulia> E(3, 4) * E(5, 6) * E(1, 2) * electron(5, 6) * occupied(2, 4) * virtual(1, 3)\nE_bj E_pq E_ai\njulia> simplify(ans) # Can not swap first and last because of non commuting between\nE_bj E_pq E_ai\njulia> E(5, 6) * E(3, 4) * E(1, 2) * electron(5, 6) * occupied(2, 4) * virtual(1, 3)\nE_pq E_bj E_ai\njulia> simplify(ans) # Can swap adjacent last two, but not first\nE_pq E_ai E_bj\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.simplify_heavy","page":"Reference/API","title":"SpinAdaptedSecondQuantization.simplify_heavy","text":"simplify_heavy(ex::Expression,\n    [mapping=GeneralOrbital => (OccupiedOrbital, VirtualOrbital)])\n\nSimilar to simplify, but enabling a few extra simplification strategies that can be quite expensive, especially as the number of summation indices in a term grows large.\n\nThe most expensive step is to iterate over every permutation of the summation indices of each term in order to find the order that has the least lexiographic ordering, which naturally has a scaling of O(n!) where n is the larget number of summation indices in a single term. This is quite managable for \"small\" numbers of indices (less than ~8), but quickly becomes unfeasible.\n\nnote: Note\nThe iteration over permutations of summation indices happens after summation indices that show up in Kronecker deltas, so if your terms contain many Kronecker deltas this might yet be possible to run.\n\nThe optional mapping argument defaults to splitting terms with general indices into a term with the index being occupied plus a term where the index is virtual, then performing simplification when all terms are split and recombining terms according to the same splitting if possible. This often allows for a few additional cancellations to occur than using only simplify If dealing with other index spaces, this splitting can be specified can be specified to be some other set of index spaces. See split_indices.\n\nExamples:\n\nHF energy with full real orbital symmetry:\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> h = ∑(rsym_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), 1:2)\n∑_pq(h_pq E_pq)\njulia> g = 1//2 * ∑(rsym_tensor(\"g\", 1:4...) * e(1:4...) * electron(1:4...), 1:4)\n1/2 ∑_pqrs(g_pqrs E_pq E_rs)\n- 1/2 ∑_pqrs(δ_qr g_pqrs E_ps)\njulia> H = simplify(h + g + real_tensor(\"h_nuc\"));\n\njulia> E_HF = simplify(hf_expectation_value(H)) # Not nice\nh_nuc\n+ 2 ∑_i(h_ii)\n+ 2 ∑_ij(g_iijj)\n- ∑_pi(g_pipi)\n+ ∑_ia(g_iaia)\njulia> simplify_heavy(E_HF) # Much nicer!\nh_nuc\n+ 2 ∑_i(h_ii)\n+ 2 ∑_ij(g_iijj)\n- ∑_ij(g_ijij)\n\nSimplification by combining terms differing by index constraints\n\njulia> ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), [1, 2])\n∑_pq(h_pq E_pq)\njulia> ans - ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * occupied(1, 2), [1, 2])\n∑_pq(h_pq E_pq)\n- ∑_ij(h_ij E_ij)\njulia> ans - ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * virtual(1, 2), [1, 2])\n∑_pq(h_pq E_pq)\n- ∑_ab(h_ab E_ab)\n- ∑_ij(h_ij E_ij)\njulia> simplify(ans)\n∑_pq(h_pq E_pq)\n- ∑_ab(h_ab E_ab)\n- ∑_ij(h_ij E_ij)\njulia> simplify_heavy(ans)\n∑_ai(h_ai E_ai)\n+ ∑_ia(h_ia E_ia)\n\n\n\n\n\n","category":"function"},{"location":"reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T<:Number","page":"Reference/API","title":"SpinAdaptedSecondQuantization.symmetrize","text":"symmetrize(ex::Expression, mappings)\n\nFunction to expand the expression ex including all permutations of indices given by mappings. This is common to use to expand all permuations among neighbouring pairs of indices, such as to compute P_ijk^abc Omega_ijk^abc. For this specific purpose we provide the convenience function make_permutation_mappings which produces all permutations between groups of indices.\n\nDocTestSetup = :(using SpinAdaptedSecondQuantization)\n\njulia> x = real_tensor(\"t\", 1, 2, 3, 4, 5, 6) *\n           occupied(2, 4, 6) * virtual(1, 3, 5)\nt_aibjck\njulia> symmetrize(x, make_permutation_mappings([(1, 2), (3, 4), (5, 6)]))\nt_aibjck\n+ t_aickbj\n+ t_bjaick\n+ t_bjckai\n+ t_ckaibj\n+ t_ckbjai\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.δ-Tuple","page":"Reference/API","title":"SpinAdaptedSecondQuantization.δ","text":"δ(indices...)\n\nUnicode alias for delta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.τ-Tuple{Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.τ","text":"τ(p, q)\n\nConstructs an expression containing a single triplet excitation operator.\n\n\n\n\n\n","category":"method"},{"location":"#SpinAdaptedSecondQuantization.jl","page":"Home","title":"SpinAdaptedSecondQuantization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpinAdaptedSecondQuantization.jl is a Julia package for doing symbolic second quantization mainly targeted at quantum chemistry methods, such as post Hartree-Fock methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the package, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.8) pkg> add SpinAdaptedSecondQuantization","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia version 1.8 or higher is required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can then be loaded","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpinAdaptedSecondQuantization","category":"page"},{"location":"#Basic-Structure","page":"Home","title":"Basic Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core type of the package is the Expression type. This contains an array of Term types. A term is a product that can contain a combination of various elements. These are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A scalar multiplier\nAn array of operators\nAn array of tensors\nAn array of Kronecker deltas\nAn array of summation indices\nA dictionary of index constraints","category":"page"},{"location":"#Indices","page":"Home","title":"Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most types will contain indices. For convenience these are represented as integers, but they are purely symbolic. When constrained to a certain index space they will be printed with names according to the semi-standard names for general molecular orbital (MO) indices pqrstuv, abcdefg and ijklmno.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default indices are unconstrained and will be printed as subscript indices ₁₂...","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Usually, however, one wants to constrain indices to a certain subspace of indices. By default the available spaces are GeneralOrbital, VirtualOrbital and OccupiedOrbital which can be used for example like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2) * constrain(1 => VirtualOrbital, 2 => OccupiedOrbital)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The shorthand functions electron(...), virtual(...) and occupied(...) can also be used","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2) * electron(1, 2)\nE(1, 2) * E(3, 4) * virtual(1, 3) * occupied(2, 4)","category":"page"},{"location":"#Operators","page":"Home","title":"Operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A small variety of operator types is supplied by defualt listed in the following table.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Operator Type constructor(s)\nSingletExcitationOperator E(p, q), e(p, q, r, s)\nFermionOperator fermion(p, σ), fermiondag(p, σ)\nBosonOperator boson(), bosondag()\nTripletExcitationOperator τ(p, q)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A few examples are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2) * electron(1, 2)\nE(1, 2) * E(3, 4) * virtual(1, 3) * occupied(2, 4)\ne(1, 2, 3, 4) * electron(1, 2, 3, 4)\nfermion(1, α) * occupied(1)\nfermiondag(2, β) * virtual(2)\nbosondag() * boson()\nτ(1, 2) * electron(1, 2)","category":"page"},{"location":"#Tensors","page":"Home","title":"Tensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest tensor type is the RealTensor which has a name and an array of indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"real_tensor(\"h\", 1, 2) * electron(1, 2)\nreal_tensor(\"g\", 1, 2, 3, 4) * electron(1, 2, 3, 4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some other types of tensors are supported with various symmetries in the indices. Supported tensor types are listed below","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tensor type constructor symmetries\nRealTensor real_tensor(name, p, ...) No symmetries\nParticleSymmetricTensor psym_tensor(name, p, ...) g₁₂₃₄ <-> g₃₄₁₂\nRealSymmetricTensor rsym_tensor(name, p, ...) g₁₂₃₄ <-> g₂₁₃₄ <-> g₄₃₂₁ <-> ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"rsym_tensor i typically used when assuming full real orbtial symmetry of integrals such as 2-fold symmetry of hpq and 8-fold symmetry of gpqrs. the psym_tensor is useful when doing coupled cluster theory, where symmetries within index pairs does not exist because the integrals are T1 transformed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Examples of symmetric tensors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rsym_tensor(\"g\", 4, 3, 1, 2) * electron(1, 2, 3, 4)\npsym_tensor(\"g\", 4, 3, 1, 2) * electron(1, 2, 3, 4)","category":"page"},{"location":"#Kronecker-Deltas","page":"Home","title":"Kronecker Deltas","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kronecker deltas constrain indices to be equal or else the term would be zero. They can have two or more indices each.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta(1, 2)\nδ(1, 2) # Unicode version equivalent to the one above\nd1 = δ(1, 2)\nd2 = δ(2, 3)\nd1 * d2 # Compacts delta expression since all are equal","category":"page"},{"location":"#Summation-Indices","page":"Home","title":"Summation Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A term can represent a sum over all values of a specific (or many) indices. A sum can be constructed using the summation function, or the unicode aliases ∑ or Σ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = summation(E(1, 2) * electron(1, 2), [1])\nb = ∑(E(1, 2) * electron(1, 2), 1:2) # Unicode\na * b # Automatically renames summation indices to not collide","category":"page"},{"location":"#Hartree-Fock-energy-expression","page":"Home","title":"Hartree-Fock energy expression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a simple example of use of the package, here is how to derive the HF energy expression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), 1:2)\ng = 1//2 * simplify(\n    ∑(psym_tensor(\"g\", 1:4...) * e(1:4...) * electron(1:4...), 1:4)\n)\nH = h + g + real_tensor(\"h_nuc\")\nE_hf = simplify_heavy(hf_expectation_value(H))","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Auto generated docs for functions and types that are not exported. Mostly for development use.","category":"page"},{"location":"internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"internals/#SpinAdaptedSecondQuantization.BosonOperator","page":"Internals","title":"SpinAdaptedSecondQuantization.BosonOperator","text":"Boson Operators\n\nThe basic boson type operator.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Constraints","page":"Internals","title":"SpinAdaptedSecondQuantization.Constraints","text":"Constraints = SortedDict{Int,Int}\n\nType alias for container of Index constraints\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.KroneckerDelta","page":"Internals","title":"SpinAdaptedSecondQuantization.KroneckerDelta","text":"KroneckerDelta\n\nType representing a Kronecker delta of two or more MO-indices.\n\nnote: Note\nWhen constructing a KroneckerDelta it will return the integer 1 if the delta does not include two or more distinkt indices.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.Operator","text":"Operator\n\nAbstact operator type which all concrete operator types (i.e. Epq, a†p) must extend.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.SingletExcitationOperator","page":"Internals","title":"SpinAdaptedSecondQuantization.SingletExcitationOperator","text":"SingletExcitationOperator\n\nThe basic E_pq type operator.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Spin","page":"Internals","title":"SpinAdaptedSecondQuantization.Spin","text":"Spin\n\nEnum type to represent spin up (α) and down (β)\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.TripletExcitationOperator","page":"Internals","title":"SpinAdaptedSecondQuantization.TripletExcitationOperator","text":"SingletExcitationOperator\n\nThe T_pq type operator.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"internals/#Base.:==-Union{Tuple{B}, Tuple{A}, Tuple{A, B}} where {A<:SpinAdaptedSecondQuantization.Operator, B<:SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"Base.:==","text":"Base.:==(::Operator, ::Operator)\n\nThis has to be explicitly implemented for each operator type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:^-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Integer}} where T<:Number","page":"Internals","title":"Base.:^","text":"Base.:(^)(ex::Expression, n::Integer)\n\nComputes ex^n by repeated multiplication.\n\nwarning: Warning\nn must be a non negative integer\n\nExamples\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> h = ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), 1:2)\n∑_pq(h_pq E_pq)\njulia> h^2\n∑_pqrs(h_pq h_rs E_pq E_rs)\njulia> h^3\n∑_pqrstu(h_pq h_rs h_tu E_pq E_rs E_tu)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.adjoint-Tuple{SpinAdaptedSecondQuantization.Expression}","page":"Internals","title":"Base.adjoint","text":"Base.adjoint(ex::Expression)\n\nTermwise adjoint ex. Equivalent to the postfix notation ex'\n\nExamples\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> Eai(a, i) = E(a, i) * occupied(i) * virtual(a)\nEai (generic function with 1 method)\njulia> T2 = 1//2 * ∑(psym_tensor(\"t\", 1:4...) * Eai(1, 2) * Eai(3, 4), 1:4)\n1/2 ∑_aibj(t_aibj E_ai E_bj)\njulia> adjoint(T2)\n1/2 ∑_aibj(t_aibj E_jb E_ia)\njulia> T2'\n1/2 ∑_aibj(t_aibj E_jb E_ia)\njulia> simplify(ans)\n1/2 ∑_iajb(t_aibj E_ia E_jb)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.isless-Union{Tuple{B}, Tuple{A}, Tuple{Type{A}, Type{B}}} where {A<:SpinAdaptedSecondQuantization.Operator, B<:SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"Base.isless","text":"Base.isless(::Operator, ::Operator)\n\nAll operator types must implement how they should be sorted among themselves (isless(::O, ::O)) and with respect to all other operator types that it is expected to be used together with (isless(::A, ::B)).\n\nThe implementation for how it sorts among the same operator type should be implemented in the definition file for that operator type.\n\nThe implementation for how the type sorts compared to other operator types should be added to the src/operators/sorting.jl file. These should be dummy routines that simply return true or false, and do not depend on the contents of the operators.\n\nnote: Note\nOnly one order needs to be implemented, meaning if isless(::A, ::B) is implemented, there is no need to also implement isless(::B, ::A)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.show-Tuple{IO, Tuple{SpinAdaptedSecondQuantization.Operator, DataStructures.SortedDict{Int64, Int64}, Dict{Int64, Tuple{Int64, Int64}}}}","page":"Internals","title":"Base.show","text":"Base.show(::IO, ::Tuple{Operator,Constraints,IndexTranslation})\n\nAll typed extending Operator must overload this function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.compact_deltas-Tuple{Vector{SpinAdaptedSecondQuantization.KroneckerDelta}}","page":"Internals","title":"SpinAdaptedSecondQuantization.compact_deltas","text":"compact_deltas(deltas::Vector{KroneckerDelta})\n\nReturns a new reduced Vector{KroneckerDelta} where there exists only one delta per group of equal indices.\n\nExample:\n\nδ_pq δ_qr δ_st -> δ_pqr δst\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.do_tensor_replacement-Tuple{SpinAdaptedSecondQuantization.Term, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.do_tensor_replacement","text":"do_tensor_replacement(t::Term, transformer)\n\nFunction that takes a term and produces the term you get by transforming its tensors according to the transformer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.exchange_indices-Tuple{SpinAdaptedSecondQuantization.KroneckerDelta, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.exchange_indices","text":"exchange_indices(d::KroneckerDelta, mapping)\n\nReturns a new KroneckerDelta with indices exchanged according to the mapping\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.exchange_indices-Tuple{SpinAdaptedSecondQuantization.Operator, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.exchange_indices","text":"exchange_indices(::Operator, mapping)\n\nAll typed extending Operator must overload this function. It should return a new operator where all indices have been exchanged according to the mapping.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.get_all_indices-Tuple{SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"SpinAdaptedSecondQuantization.get_all_indices","text":"get_all_indices(::Operator)\n\nAll typed extending Operator must overload this function. It should return an iteratable over all the MO-indices contained in the operator in order.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.nested_commutator-Tuple{Any, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.nested_commutator","text":"commutator(A, Bs)\n\nCompute nested commutator with all expressions in iteratable Bs.\n\nA B_1 B_2 \n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.reductive_commutator-Tuple{SpinAdaptedSecondQuantization.Operator, SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"SpinAdaptedSecondQuantization.reductive_commutator","text":"reductive_commutator(::Operator, ::Operator)\n\nDefines how operators commute. This will act as either a commutator or anticommutator depending on which reduces the rank of the resulting operators.\n\nReturns a Tuple{Int,Expression} which gives the type of commutator used and the resulting expression. The type is signaled by returning 1 or -1 as the first element of the tuple. This represents the sign change by commutation which is 1 for a normal commutator (A B = 0  AB == BA) and -1 for an anticommutator (A B_+ = 0  AB = -BA)\n\nThis should be implemented for all pairs of operators types that are expected to show up in the same expression. The implementations should be put in the src/operators/commutation_relations.jl file.\n\nnote: Note\nOnly one order needs to be implemented, meaning if reductive_commutator(::A, ::B) is implemented, there is no need to also implement reductive_commutator(::B, ::A)\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.split_indices-Tuple{SpinAdaptedSecondQuantization.Expression, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.split_indices","text":"split_indices(ex::Expression, mapping)\n\nSplits the indices of each term according to the given mapping.\n\njulia> using SpinAdaptedSecondQuantization\n\njulia> h = ∑(real_tensor(\"h\", 1, 2) * E(1, 2) * electron(1, 2), 1:2)\n∑_pq(h_pq E_pq)\n\njulia> SASQ.split_indices(h,GeneralOrbital => (OccupiedOrbital, VirtualOrbital))\n∑_ab(h_ab E_ab)\n+ ∑_ai(h_ai E_ai)\n+ ∑_ia(h_ia E_ia)\n+ ∑_ij(h_ij E_ij)\n\n\n\n\n\n","category":"method"}]
}
