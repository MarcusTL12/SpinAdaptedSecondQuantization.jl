<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CCSD example · SpinAdaptedSecondQuantization.jl</title><meta name="title" content="CCSD example · SpinAdaptedSecondQuantization.jl"/><meta property="og:title" content="CCSD example · SpinAdaptedSecondQuantization.jl"/><meta property="twitter:title" content="CCSD example · SpinAdaptedSecondQuantization.jl"/><meta name="description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><meta property="og:description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><meta property="twitter:description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpinAdaptedSecondQuantization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>CCSD example</a><ul class="internal"><li><a class="tocitem" href="#Hamiltonian"><span>Hamiltonian</span></a></li><li><a class="tocitem" href="#Cluster-Operator"><span>Cluster Operator</span></a></li><li><a class="tocitem" href="#Similrarity-transformed-Hamiltonian"><span>Similrarity transformed Hamiltonian</span></a></li><li><a class="tocitem" href="#Ground-State-Energy-Expression-and-Equations"><span>Ground State Energy Expression and Equations</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference/API</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CCSD example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CCSD example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/main/docs/src/ccsd_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Coupled-Cluster-Singles-and-Doubles-Example"><a class="docs-heading-anchor" href="#Coupled-Cluster-Singles-and-Doubles-Example">Coupled Cluster Singles and Doubles Example</a><a id="Coupled-Cluster-Singles-and-Doubles-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-Cluster-Singles-and-Doubles-Example" title="Permalink"></a></h1><p>Here is a detailed example of how to derive common expressions and equations for the closed shell CCSD method. This will also serve as a way of showcasing the various functionality of the package.</p><h2 id="Hamiltonian"><a class="docs-heading-anchor" href="#Hamiltonian">Hamiltonian</a><a id="Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian" title="Permalink"></a></h2><p>For the hamiltonian we will use the familiar expression for the non-relativistic electronic hamiltonian, however we will express it in terms of the fock matrix instead of the normal one-electron matrix</p><p><span>$F_{pq} = h_{pq} + \sum_{i}{\left(2 g_{pqii} - g_{piiq}\right)}$</span></p><p><span>$h_{pq} = F_{pq} - \sum_{i}{\left(2 g_{pqii} - g_{piiq}\right)}$</span></p><p>This is because every expression except the HF energy looks simpler expressed in terms of the fock matrix. In code we then define the hamiltonian as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SpinAdaptedSecondQuantization</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = ∑((
               real_tensor(&quot;F&quot;, 1, 2) +
               ∑((-2 * psym_tensor(&quot;g&quot;, 1, 2, 3, 3) +
                   psym_tensor(&quot;g&quot;, 1, 3, 3, 2)) * occupied(3), [3])
           ) * E(1, 2) * electron(1, 2), 1:2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_pq(F_pq E_pq)
- 2 ∑_pqi(g_pqii E_pq)
+ ∑_pqi(g_piiq E_pq)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = 1//2 * simplify(
           ∑(psym_tensor(&quot;g&quot;, 1:4...) * e(1:4...) * electron(1:4...), 1:4)
       )</code><code class="nohighlight hljs ansi" style="display:block;">- 1/2 ∑_pqr(g_prrq E_pq)
+ 1/2 ∑_pqrs(g_pqrs E_pq E_rs)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; H = h + g</code><code class="nohighlight hljs ansi" style="display:block;">∑_pq(F_pq E_pq)
- 2 ∑_pqi(g_pqii E_pq)
- 1/2 ∑_pqr(g_prrq E_pq)
+ ∑_pqi(g_piiq E_pq)
+ 1/2 ∑_pqrs(g_pqrs E_pq E_rs)</code></pre><p>We omit the nuclear repulsion term and we do not assume any symmetry in our integrals apart from the particle exchange symmetry in the two electron integrals. We do this since we can then use the T1 transformed integrals allowing us to ignore the T1 operator when deriving equations.</p><p>We can derive the HF energy expression for the Hamiltonian in terms of the Fock matrix as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E_HF = simplify_heavy(hf_expectation_value(H))</code><code class="nohighlight hljs ansi" style="display:block;">2 ∑_i(F_ii)
- 2 ∑_ij(g_iijj)
+ ∑_ij(g_ijji)</code></pre><h2 id="Cluster-Operator"><a class="docs-heading-anchor" href="#Cluster-Operator">Cluster Operator</a><a id="Cluster-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Operator" title="Permalink"></a></h2><p>The cluster operator we define then as only the T2 operator as the T1 amplitudes are included in the T1 transformed integrals.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T2 = 1//2 * ∑(psym_tensor(&quot;t&quot;, 1:4...) * E(1, 2) * E(3, 4) *
       occupied(2, 4) * virtual(1, 3), 1:4)</code><code class="nohighlight hljs ansi" style="display:block;">1/2 ∑_aibj(t_aibj E_ai E_bj)</code></pre><h2 id="Similrarity-transformed-Hamiltonian"><a class="docs-heading-anchor" href="#Similrarity-transformed-Hamiltonian">Similrarity transformed Hamiltonian</a><a id="Similrarity-transformed-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Similrarity-transformed-Hamiltonian" title="Permalink"></a></h2><p>A central operator in coupled cluster theory is the similarity transformed Hamiltonian operator</p><p><span>$\bar H = e^{-T} H e^T$</span></p><p>This is usually computed using the Baker-Campbell-Hausdorff (BCH) expansion</p><p><span>$e^{-B} A e^B = A + [A, B] + \frac12 [[A, B], B] + \frac{1}{3!} [[[A], B], B] + ...$</span></p><p>A nice feature of this expansion for the electronic hamiltionian and the cluster operator is that it truncates after the 4th order term (5 terms). This is because the 5th order expression is zero</p><p><span>$[[[[[H, E_{ai}], E_{bj}], E_{ck}], E_{dl}], E_{em}] = 0$</span></p><p>This means that we can explicitly compute the full similarity transformed Hamiltonian with no fear of missing any terms. We supply the function <code>bch(A, B, n)</code> which computes the BCH expansion to nth order.</p><div class="admonition is-info" id="Note-eb5fbcd5717aad11"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-eb5fbcd5717aad11" title="Permalink"></a></header><div class="admonition-body"><p>We also supply the functon <code>bch(A, [B1, B2, ...], n)</code> which is equivalent to <code>bch(A, B1 + B2 + ..., n)</code> when all of <code>B1, B2, ...</code> comute among each other, but is much faster as it avoids computing equivalent terms such as <span>$[[A, B_1], B_2]$</span> and <span>$[[A, B_2], B_1]$</span>. This can be especially useful for higher order coupled cluster methods such as CCSDT and beyond, as well as exotic methods such as QED-CC and NEO-CC.</p></div></div><p>In code this looks like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Hbar = simplify(bch(H, T2, 4)); # Avoid printing as this is quite long</code></pre><h2 id="Ground-State-Energy-Expression-and-Equations"><a class="docs-heading-anchor" href="#Ground-State-Energy-Expression-and-Equations">Ground State Energy Expression and Equations</a><a id="Ground-State-Energy-Expression-and-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ground-State-Energy-Expression-and-Equations" title="Permalink"></a></h2><p>The coupled cluster ground state energy and equations are obtained by projecting the similarity constrained Schrödinger equation</p><p><span>$\bar H |\text{HF}\rangle = E |\text{HF}\rangle$</span></p><p>onto a set of bra states. The energy is obtained by projecting on the HF bra</p><p><span>$E_0 = \langle\text{HF}| \bar H |\text{HF}\rangle$</span></p><p>while the coupled cluster wave function is determined by projecting on a set of excited bra states determined from the cluster operator</p><p><span>$\langle\mu| \bar H |\text{HF}\rangle = 0$</span></p><p>In both cases we require the quantity <span>$\bar H |\text{HF}\rangle$</span> which we can explicitly compute by the function <code>act_on_ket(ex, [max_ops])</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Hbar_ket = simplify(act_on_ket(Hbar, 2)); # Avoid printing long expression</code></pre><p>Here we choose to throw away any terms with more than two operators as in CCSD we are never projecting on any bra that is more than doubly excited. This can speed up the projection and further operations by a bit.</p><h3 id="Energy"><a class="docs-heading-anchor" href="#Energy">Energy</a><a id="Energy-1"></a><a class="docs-heading-anchor-permalink" href="#Energy" title="Permalink"></a></h3><p>To obtain the energy expression we project the Hbar<em>ket on HF from the left. This can be nicely done using the `act</em>on<em>bra(ex, [max</em>ops])` function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E0 = simplify_heavy(act_on_bra(Hbar_ket))</code><code class="nohighlight hljs ansi" style="display:block;">2 ∑_i(F_ii)
- 2 ∑_ij(g_iijj)
+ ∑_ij(g_ijji)
+ 2 ∑_iajb(g_iajb t_aibj)
- ∑_iajb(g_iajb t_ajbi)</code></pre><p>Since the interesting part here is that which differs from HF, we can get the correlation energy as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E_corr = E0 - E_HF</code><code class="nohighlight hljs ansi" style="display:block;">2 ∑_iajb(g_iajb t_aibj)
- ∑_iajb(g_iajb t_ajbi)</code></pre><p>Here we see a very common pattern; the 2 * coulomb - 1 * exchange pattern where we have terms that differ by a prefactor of <span>$-\frac12$</span> and an exchange of index 2 and 4 of a 4 index tensor, such as the two electron integrals or the T2 amplitudes. We usually define separate tensor names for these patterns  such as</p><p><span>$L_{pqrs} = 2 g_{pqrs} - g_{psrq}$</span></p><p>and</p><p><span>$u_{aibj} = 2 t_{aibj} - t_{ajbi}$</span></p><p>We provide a pair of functions to look for this pattern in expressions. firstly and mainly <a href="../reference/#SpinAdaptedSecondQuantization.look_for_tensor_replacements-Tuple{SpinAdaptedSecondQuantization.Expression, Any}"><code>look_for_tensor_replacements</code></a> function which is the actual engine that takes an expression and a tensor transformation function and looks for terms that are equal up to this transformation. We provide the utility function <a href="../reference/#SpinAdaptedSecondQuantization.make_exchange_transformer-Tuple{Any, Any}"><code>make_exchange_transformer</code></a> which produces a transformer that looks for the 2 * coulomb - 1 * exchange pattern. We can show this in action on the correlation energy looking for both the patterns mentioned above</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(E_corr, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">∑_iajb(L_iajb t_aibj)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(E_corr, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">∑_iajb(g_iajb u_aibj)</code></pre><h3 id="Omega-Equations"><a class="docs-heading-anchor" href="#Omega-Equations">Omega Equations</a><a id="Omega-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Omega-Equations" title="Permalink"></a></h3><h4 id="Biorthogonal-Bra"><a class="docs-heading-anchor" href="#Biorthogonal-Bra">Biorthogonal Bra</a><a id="Biorthogonal-Bra-1"></a><a class="docs-heading-anchor-permalink" href="#Biorthogonal-Bra" title="Permalink"></a></h4><p>For the singles equations we want to compute quantity</p><p><span>$\Omega_i^a = \bar{\left\langle_i^a\right|} \bar H |\text{HF}\rangle$</span></p><p>where the bra <span>$\bar{\left\langle_i^a\right|}$</span> is the biorthogonal bra state for the singly excited determinant</p><p><span>$\left|_i^a\right\rangle = E_{ai} |\text{HF}\rangle$</span></p><p>defined such that</p><p><span>$\left\langle\bar{_i^a}|_j^b\right\rangle = \delta_{ij} \delta_{ab}$</span></p><p>For a singly excited determinant we can explicitly express this biorthogonal bra simply as</p><p><span>$\bar{\left\langle_i^a\right|} = \frac12 \langle\text{HF}| E_{ia}$</span></p><p>As a quick example we can show this</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bra = 1//2 * E(2, 1) * occupied(2) * virtual(1)</code><code class="nohighlight hljs ansi" style="display:block;">1/2 E_ia</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket = E(3, 4) * occupied(4) * virtual(3)</code><code class="nohighlight hljs ansi" style="display:block;">E_ai</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hf_expectation_value(bra * ket)</code><code class="nohighlight hljs ansi" style="display:block;">δ_ab δ_ij</code></pre><p>However for higher excitations the biorthogonal bra states can not be as easily expressed explicitly. For doubly excited determinants we want a biorthornormal bra state <span>$\bar{\left\langle_{ij}^{ab}\right|}$</span> such that</p><p><span>$\left\langle\bar{_{ij}^{ab}}|_{kl}^{cd}\right\rangle = P_{ai,bj} \delta_{ik} \delta_{jl} \delta_{ac} \delta_{bd} = \delta_{ik} \delta_{jl} \delta_{ac} \delta_{bd} + \delta_{jk} \delta_{il} \delta_{bc} \delta_{ad}$</span></p><p>with the permutation operator <span>$P_{ai,bj}$</span> generating the equivalent permutations due to the particle symmetry in the doubly excited determinant</p><p><span>$\left|_{ij}^{ab}\right\rangle = \left|_{ji}^{ba}\right\rangle = E_{ai} E_{bj} |\text{HF}\rangle = E_{bj} E_{ai} |\text{HF}\rangle$</span></p><p>We can write the biorthogonal bra explicitly as</p><p><span>$\bar{\left\langle_{ij}^{ab}\right|} = \frac13 \left\langle_{ij}^{ab}\right| + \frac16 \left\langle_{ji}^{ab}\right| = \langle\text{HF}| \left(     \frac13 E_{jb} E_{ia} +     \frac16 E_{ib} E_{ja} \right)$</span></p><p>Which we can confirm using the code</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bra = (1//3 * E(4, 3) * E(2, 1) + 1//6 * E(2, 3) * E(4, 1)) *
           occupied(2, 4) * virtual(1, 3)</code><code class="nohighlight hljs ansi" style="display:block;">1/6 E_ib E_ja
+ 1/3 E_jb E_ia</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket = E(5, 6) * E(7, 8) * occupied(6, 8) * virtual(5, 7)</code><code class="nohighlight hljs ansi" style="display:block;">E_ai E_bj</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hf_expectation_value(bra * ket)</code><code class="nohighlight hljs ansi" style="display:block;">δ_ac δ_ik δ_bd δ_jl
+ δ_ad δ_il δ_bc δ_jk</code></pre><div class="admonition is-info" id="Note-ab42acdfdaf944c1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ab42acdfdaf944c1" title="Permalink"></a></header><div class="admonition-body"><p>For higher order excited determinants such as triples, quadruples, etc. it is, however, not possible to explicitly express a biorthogonal state that has the desired properties. This is related to the fact that the expression is zero</p><p><span>$P^{abc} E_{ai} E_{bj} E_{ck} = 0$</span></p><p>It is, however, still useful to be able to derive the expressions you would get if you project on a biorthogonal basis anyway, even if it is not expressible as a linear combination of excited determinants. For the triples for example, we can define two distinct expressions</p><p><span>$\Omega_{ijk}^{abc} = \left\langle\bar{_{ijk}^{abc}}\right| \bar H |\text{HF}\rangle$</span></p><p><span>$\tilde \Omega_{ijk}^{abc} = \left\langle_{ijk}^{abc}\right| \bar H |\text{HF}\rangle$</span></p><p>the latter of which is the quantity that &quot;actually exists&quot; as a projection onto a set of bra states which are expressible as excited determinants and represent the equations which are to be solved to obtain the coupled cluster wave function. The two <span>$\Omega$</span> expressions are related by a non invertible linear transformation</p><p><span>$\tilde \Omega_{ijk}^{abc} = \sum_{a&#39;i&#39;b&#39;j&#39;c&#39;k&#39;}{     S_{ijki&#39;j&#39;k&#39;}^{abca&#39;b&#39;c&#39;}     \Omega_{i&#39;j&#39;k&#39;}^{a&#39;b&#39;c&#39;} }$</span></p><p>We can then see that if one finds amplitudes such that the <span>$\Omega$</span> found by using the biorthogonal states they will also make the <span>$\tilde \Omega$</span> be zero, which is the condition we want to solve for. This is nice as we can safely &quot;pretend&quot; there exists a biorthogonal basis which produces much simpler expressions and are therefore more efficient to derive and numerically compute.</p></div></div><p>Since we do not want to (and often can not, see note above) make an explicit expression for a biorthogonal bra we provide the function <a href="../reference/#SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T&lt;:Number"><code>project_biorthogonal</code></a> which lets us insert Kronecker deltas according to the definition of the biorthogonality in addition to the <a href="../reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a> function to expand the permutations required by the biorthogonality. We can reproduce the same behaviour as for the biorthogonal doubles from above as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket = E(5, 6) * E(7, 8) * occupied(6, 8) * virtual(5, 7)</code><code class="nohighlight hljs ansi" style="display:block;">E_ai E_bj</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(ket, E(1, 2) * E(3, 4))</code><code class="nohighlight hljs ansi" style="display:block;">δ_ac δ_ik δ_bd δ_jl</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]))</code><code class="nohighlight hljs ansi" style="display:block;">δ_ac δ_ik δ_bd δ_jl
+ δ_ad δ_il δ_bc δ_jk</code></pre><p>Here we supplied the &quot;template&quot; ket <code>E(1, 2) * E(3, 4)</code> which is that we want to project on the biorthogonal bra of.</p><h4 id="Singles-Equations"><a class="docs-heading-anchor" href="#Singles-Equations">Singles Equations</a><a id="Singles-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Singles-Equations" title="Permalink"></a></h4><p>We can use the <a href="../reference/#SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T&lt;:Number"><code>project_biorthogonal</code></a> function to project <code>Hbar_ket</code> on the singles biorthogonal bra and get an expression for <span>$\Omega_i^a$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_ai = project_biorthogonal(Hbar_ket, E(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">F_ai
+ 2 ∑_jb(F_jb t_aibj)
- ∑_jb(F_jb t_ajbi)
+ 2 ∑_bjc(g_abjc t_bicj)
- ∑_bjc(g_abjc t_bjci)
- 2 ∑_jkb(g_jikb t_ajbk)
+ ∑_jkb(g_jikb t_akbj)</code></pre><p>Here we also see the 2 * coulomb - 1 * exchange pattern show up again, so we can simplify by.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_ai = look_for_tensor_replacements(omega_ai,
           make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">F_ai
+ ∑_jb(F_jb u_aibj)
+ ∑_bjc(g_abjc u_bicj)
- ∑_jkb(g_jikb u_ajbk)</code></pre><p>Which produces a nice simplified expression for the singes part of the CCSD equations.</p><h4 id="Doubles-Equations"><a class="docs-heading-anchor" href="#Doubles-Equations">Doubles Equations</a><a id="Doubles-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Doubles-Equations" title="Permalink"></a></h4><p>Here we want to derive the expression for the doubles <span>$\Omega$</span></p><p><span>$\Omega_{ij}^{ab} = \bar{\left\langle_{ij}^{ab}\right|} \bar H |\text{HF}\rangle$</span></p><p>Just like for the singles equations we project on a biorthogonal bra, though now using a doubly excited ket as the template, and we need to symmetrize to include the pertmutations caused by the particle symmetry of the biorthogonal bra.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(Hbar_ket, E(1, 2) * E(3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj = simplify_heavy(
           symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)])));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_u = look_for_tensor_replacements(omega_aibj,
           make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">g_aibj
+ ∑_c(F_ac t_bjci)
+ ∑_c(F_bc t_aicj)
- ∑_k(F_ki t_akbj)
- ∑_k(F_kj t_aibk)
+ ∑_cd(g_acbd t_cidj)
- ∑_ck(g_acki t_bjck)
- ∑_ck(g_ackj t_bkci)
- ∑_ck(g_bcki t_akcj)
- ∑_ck(g_bckj t_aick)
+ ∑_kl(g_kilj t_akbl)
+ ∑_kc(g_aikc u_bjck)
+ ∑_kc(g_bjkc u_aick)
+ ∑_kcld(g_kcld t_aicl t_bkdj)
+ ∑_kcld(g_kcld t_akbl t_cidj)
+ ∑_kcld(g_kcld t_akdj t_blci)
- ∑_kcld(g_kcld t_aibk u_cjdl)
- ∑_kcld(g_kcld t_aicj u_bkdl)
- ∑_kcld(g_kcld t_akbj u_cidl)
- ∑_kcld(g_kcld t_bjci u_akdl)
- ∑_kcld(g_kcld t_bjcl u_aidk)
+ ∑_kcld(g_kcld u_aick u_bjdl)</code></pre><p>Here we needed to use the (sometimes) expensive <a href="../reference/#SpinAdaptedSecondQuantization.simplify_heavy"><code>simplify_heavy</code></a> function to fully simplify, as well as recognizing the 2 * coulomb - 1 * exchange pattern for the T2 amplitudes. Now we have a correct and rather nice expression for the doubles equations, however, because of the particle symmetry of the bra that we introduced with the call to <a href="../reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a> some terms are equal after permuting the indices (a, i) &lt;-&gt; (b, j). Computing all of these redundant terms leads to a lot of unnecessary terms to code and compute, so it is much more efficient to only code the non-redundant ones, then symmetrize the final result numerically. To help with this, we provide the <a href="../reference/#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>desymmetrize</code></a> function which sort of acts like the reverse of <a href="../reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a>. We can call this function on our <span>$\Omega_{ij}^{ab}$</span> expression</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_r, omega_aibj_ss, omega_aibj_ns = desymmetrize(
           omega_aibj_u, make_permutation_mappings([(1, 2), (3, 4)])
       );</code><code class="nohighlight hljs ansi" style="display:block;">Expression([t]) = ∑_kcld(g_kcld t_aicl t_bkdj)
other_inds = Dict(14 =&gt; 1)
Expression([t]) = - ∑_kcld(g_kcld t_bjcl u_aidk)
other_inds = Dict(21 =&gt; 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_r</code><code class="nohighlight hljs ansi" style="display:block;">∑_c(F_ac t_bjci)
- ∑_k(F_ki t_akbj)
- ∑_ck(g_acki t_bjck)
- ∑_ck(g_ackj t_bkci)
+ ∑_kc(g_aikc u_bjck)
- ∑_kcld(g_kcld t_aibk u_cjdl)
- ∑_kcld(g_kcld t_aicj u_bkdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_ss</code><code class="nohighlight hljs ansi" style="display:block;">g_aibj
+ ∑_cd(g_acbd t_cidj)
+ ∑_kl(g_kilj t_akbl)
+ ∑_kcld(g_kcld t_akbl t_cidj)
+ ∑_kcld(g_kcld t_akdj t_blci)
+ ∑_kcld(g_kcld u_aick u_bjdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_ns</code><code class="nohighlight hljs ansi" style="display:block;">∑_kcld(g_kcld t_aicl t_bkdj)
- ∑_kcld(g_kcld t_bjcl u_aidk)</code></pre><p>The <a href="../reference/#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>desymmetrize</code></a> function returns three expressions. The first <code>omega_aibj_r</code> contains the terms it found redundant permutations of elsewhere in the original expression. These needs to be symmetrized to obtain the correct expression. The second term <code>omega_aibj_ss</code> contains the &quot;self-symmetric&quot; terms. These are the terms which themselves carry the symmetry requested and can be evaluated as-is. The third and last term <code>omega_aibj_ns</code> are the &quot;non-symmetric&quot; terms. Interestingly, we have here gotten two terms in the non-symmetric expression, even though the result should be symmetric. Under closer inspection one can see that the two &quot;non-symmetric&quot; terms are indeed symmetric if one re-expands the <span>$u_{aidk}$</span> tensor in terms of <span>$t$</span>. To avoid having non-symmetric terms we can instead directly desymmetrize the omega before looking for coulomb - exchange symmetry.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_r, omega_aibj_ss, omega_aibj_ns = desymmetrize(
           omega_aibj, make_permutation_mappings([(1, 2), (3, 4)])
       );</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(omega_aibj_r, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">∑_c(F_ac t_bjci)
- ∑_k(F_ki t_akbj)
+ ∑_kc(L_aikc t_bjck)
- ∑_kc(g_aikc t_bkcj)
- ∑_ck(g_ackj t_bkci)
- ∑_kcld(L_kcld t_aibk t_cjdl)
- ∑_kcld(L_kcld t_aicj t_bkdl)
- ∑_kcld(L_kcld t_aick t_bldj)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(omega_aibj_ss, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">g_aibj
+ ∑_cd(g_acbd t_cidj)
+ ∑_kl(g_kilj t_akbl)
+ 2 ∑_kcld(L_kcld t_aick t_bjdl)
+ ∑_kcld(g_kcld t_akbl t_cidj)
+ ∑_kcld(g_kcld t_akci t_bldj)
+ ∑_kcld(g_kcld t_akdj t_blci)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_ns</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>where we see that the non-symmetric part is indeed zero, but we have lost the ability to remove all prefactors. Counting total terms we can see that both strategies give 15 terms in total, so the cost should not be much different, but it can be nice to keep in mind. In any case to evaluate the full doubles omega one needs to symmetrize the redundant expression, and add the direct evaluation of the self-symmetric and apparent non-symmetric expression which we can write as</p><p><span>$\Omega_{ij}^{ab} = (\Omega_{\text{ss}})_{ij}^{ab} + (\Omega_{\text{ns}})_{ij}^{ab} + P_{ij}^{ab} (\Omega_{\text{s}})_{ij}^{ab}$</span></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference/API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 19 July 2025 10:16">Saturday 19 July 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
