<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference/API · SpinAdaptedSecondQuantization.jl</title><meta name="title" content="Reference/API · SpinAdaptedSecondQuantization.jl"/><meta property="og:title" content="Reference/API · SpinAdaptedSecondQuantization.jl"/><meta property="twitter:title" content="Reference/API · SpinAdaptedSecondQuantization.jl"/><meta name="description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><meta property="og:description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><meta property="twitter:description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpinAdaptedSecondQuantization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../ccsd_example/">CCSD example</a></li><li class="is-active"><a class="tocitem" href>Reference/API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference/API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference/API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference/API"><a class="docs-heading-anchor" href="#Reference/API">Reference/API</a><a id="Reference/API-1"></a><a class="docs-heading-anchor-permalink" href="#Reference/API" title="Permalink"></a></h1><p>Auto generated docs for all exported functions and types.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.E-Tuple{Any, Any}" href="#SpinAdaptedSecondQuantization.E-Tuple{Any, Any}"><code>SpinAdaptedSecondQuantization.E</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">E(p, q)</code></pre><p>Constructs an expression containing a single excitation operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/operators/singlet_excitation_operator.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.act_eT_on_bra-Tuple{Any, Any}" href="#SpinAdaptedSecondQuantization.act_eT_on_bra-Tuple{Any, Any}"><code>SpinAdaptedSecondQuantization.act_eT_on_bra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">act_eT_on_bra(braop::Expression, T::Expression; [max_n=Inf], [max_ops=Inf])</code></pre><p>computes</p><p><span>$\langle\text{HF}| \text{braop} e^T$</span></p><p>This can be useful for evaluating certain coupled cluster expressions from left to right. Since the cluster operator T is purely exciting acting <span>$e^T$</span> to the left will terminate after only a few terms depending on the left state being projected on.</p><div class="admonition is-warning" id="Warning-149847e0b0d958e8"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-149847e0b0d958e8" title="Permalink"></a></header><div class="admonition-body"><p>If <code>T</code> contains de-excitations, the expression will not truncate and the parameter <code>max_n</code> must be specified with a finite positive integer for the function to terminate, truncating the expression. <code>max_n</code> specifies the highest order term from the taylor expansion of <code>e^T</code> to include. If <code>T</code> is purely exciting, the expansion exits early when it terminates.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L747-L768">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.act_on_bra" href="#SpinAdaptedSecondQuantization.act_on_bra"><code>SpinAdaptedSecondQuantization.act_on_bra</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">act_on_bra(x::Expression, [max_ops=Inf])</code></pre><p>Projects <code>x</code> on a HF bra by projecting the adjoint on a ket and ajointing the result.</p><pre><code class="language-julia hljs">act_on_bra(x, max_ops=Inf) = act_on_ket(x&#39;, max_ops)&#39;</code></pre><p>See <a href="#SpinAdaptedSecondQuantization.act_on_ket-Tuple{SpinAdaptedSecondQuantization.Operator}"><code>act_on_ket</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L731-L742">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.act_on_ket-Tuple{SpinAdaptedSecondQuantization.Operator}" href="#SpinAdaptedSecondQuantization.act_on_ket-Tuple{SpinAdaptedSecondQuantization.Operator}"><code>SpinAdaptedSecondQuantization.act_on_ket</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">act_on_ket(::Operator)</code></pre><p>All typed extending <code>Operator</code> must overload this function. It should return the expression you end up with after acting the operator on a normal RHF ket.</p><p>Example:</p><p><span>$E_{p q} |HF⟩ = (2 δ_{p q} C(p∈O,q∈O) + E_{p q} C(p∈V,q∈O)) |HF⟩$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/operator.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.anticommutator-Union{Tuple{B}, Tuple{A}, Tuple{SpinAdaptedSecondQuantization.Expression{A}, SpinAdaptedSecondQuantization.Expression{B}}} where {A&lt;:Number, B&lt;:Number}" href="#SpinAdaptedSecondQuantization.anticommutator-Union{Tuple{B}, Tuple{A}, Tuple{SpinAdaptedSecondQuantization.Expression{A}, SpinAdaptedSecondQuantization.Expression{B}}} where {A&lt;:Number, B&lt;:Number}"><code>SpinAdaptedSecondQuantization.anticommutator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">anticommutator(a::Expression, b::Expression)</code></pre><p>Compute commutator between <code>a</code> and <code>b</code>. This is computed termwise using the <a href="../internals/#SpinAdaptedSecondQuantization.reductive_commutator-Tuple{SpinAdaptedSecondQuantization.Operator, SpinAdaptedSecondQuantization.Operator}"><code>reductive_commutator</code></a> function, then adding/subtracting the swapped result if the reductive commutator for a given pair of terms turned out to be an commutator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L568-L575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.bch-Tuple{Any, AbstractArray, Any}" href="#SpinAdaptedSecondQuantization.bch-Tuple{Any, AbstractArray, Any}"><code>SpinAdaptedSecondQuantization.bch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bch(A, Bs::AbstractArray, n)</code></pre><p>Equivalent to <code>bch(A, sum(Bs), n)</code> if all <code>Bs</code> commute with eachother, but evalutating in a smart way in order to avoid computing equivalent terms many times, for example instead of computing both <span>$rac12 [[A, B_1], B_2]$</span> and <span>$rac12 [[A, B_2], B_1]$</span>, it will only compute the first one and multiply by 2. This can be much faster if one has many commuting terms in <code>Bs</code>.</p><div class="admonition is-warning" id="Warning-db94923fad768a37"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-db94923fad768a37" title="Permalink"></a></header><div class="admonition-body"><p>Should not be used if some expressions in <code>Bs</code> do not commute.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L678-L689">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.bch-Tuple{Any, SpinAdaptedSecondQuantization.Expression, Any}" href="#SpinAdaptedSecondQuantization.bch-Tuple{Any, SpinAdaptedSecondQuantization.Expression, Any}"><code>SpinAdaptedSecondQuantization.bch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bch(A, B, n)</code></pre><p>Compute Baker-Campbell-Haussdorff expansion</p><p><span>$e^{-B} A e^B = A + [A, B] + \frac{1}{2!} [[A, B], B] + \frac{1}{3!} [[[A, B], B], B] + \frac{1}{n!} [...[[[A, B], B], B], ...B]$</span></p><p>up to nth order. Terminates if commutator becomes zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L700-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.commutator-Tuple{Any, Any, Vararg{Any}}" href="#SpinAdaptedSecondQuantization.commutator-Tuple{Any, Any, Vararg{Any}}"><code>SpinAdaptedSecondQuantization.commutator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">commutator(A, B, C, ...)</code></pre><p>Computes the nested commutator <span>$[...[[A, B], C], ...]$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L602-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.commutator-Tuple{SpinAdaptedSecondQuantization.Expression, SpinAdaptedSecondQuantization.Expression, Integer}" href="#SpinAdaptedSecondQuantization.commutator-Tuple{SpinAdaptedSecondQuantization.Expression, SpinAdaptedSecondQuantization.Expression, Integer}"><code>SpinAdaptedSecondQuantization.commutator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">commutator(A::Expression, B::Expression, n::Integer)</code></pre><p>Compute <code>n</code> nested commutators <span>$[...[[[A], B], B]..., B]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L587-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.commutator-Union{Tuple{B}, Tuple{A}, Tuple{SpinAdaptedSecondQuantization.Expression{A}, SpinAdaptedSecondQuantization.Expression{B}}} where {A&lt;:Number, B&lt;:Number}" href="#SpinAdaptedSecondQuantization.commutator-Union{Tuple{B}, Tuple{A}, Tuple{SpinAdaptedSecondQuantization.Expression{A}, SpinAdaptedSecondQuantization.Expression{B}}} where {A&lt;:Number, B&lt;:Number}"><code>SpinAdaptedSecondQuantization.commutator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">commutator(a::Expression, b::Expression)</code></pre><p>Compute commutator between <code>a</code> and <code>b</code>. This is computed termwise using the <a href="../internals/#SpinAdaptedSecondQuantization.reductive_commutator-Tuple{SpinAdaptedSecondQuantization.Operator, SpinAdaptedSecondQuantization.Operator}"><code>reductive_commutator</code></a> function, then adding/subtracting the swapped result if the reductive commutator for a given pair of terms turned out to be an anti-commutator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L547-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.convert_to_elementary_operators-Union{Tuple{SpinAdaptedSecondQuantization.Expression{T}}, Tuple{T}} where T&lt;:Number" href="#SpinAdaptedSecondQuantization.convert_to_elementary_operators-Union{Tuple{SpinAdaptedSecondQuantization.Expression{T}}, Tuple{T}} where T&lt;:Number"><code>SpinAdaptedSecondQuantization.convert_to_elementary_operators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_to_elementary_operators(ex::Expression)</code></pre><p>converts all operators to their representation using &quot;elementary&quot; annihilation and creation operators if implemented for all operator types in <code>ex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L788-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.delta-Tuple" href="#SpinAdaptedSecondQuantization.delta-Tuple"><code>SpinAdaptedSecondQuantization.delta</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delta(indices...)</code></pre><p>Construct an expression consisting of a single Kronecker delta of the given indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/kronecker_delta.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number" href="#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>SpinAdaptedSecondQuantization.desymmetrize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">desymmetrize(ex::Expression, mappings)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/desymmetrization.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.disable_color-Tuple{Int64}" href="#SpinAdaptedSecondQuantization.disable_color-Tuple{Int64}"><code>SpinAdaptedSecondQuantization.disable_color</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">disable_color(S)</code></pre><p>Disables the coloring for a specific orbital space. This can be useful when dealing with a medium-large number of orbital spaces, and having distinguishable colors is infeasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/index_spaces.jl#L265-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.disable_color-Tuple{}" href="#SpinAdaptedSecondQuantization.disable_color-Tuple{}"><code>SpinAdaptedSecondQuantization.disable_color</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">disable_color()</code></pre><p>Disables the coloring of MO-indices to indicate orbital space constraints globally. This will make all constraints be printed explicitly which can make some terms a bit long to read. Color is enabled by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/index_spaces.jl#L253-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.disable_index_translation-Tuple{}" href="#SpinAdaptedSecondQuantization.disable_index_translation-Tuple{}"><code>SpinAdaptedSecondQuantization.disable_index_translation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">disables_index_translation()</code></pre><p>Disables the translation of summation indices over occupied and virtual to be printed as ijkl... and abcd... respectively instead of pqrs...</p><p>See <a href="#SpinAdaptedSecondQuantization.enable_index_translation-Tuple{}"><code>enable_index_translation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/index_spaces.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.e-NTuple{4, Any}" href="#SpinAdaptedSecondQuantization.e-NTuple{4, Any}"><code>SpinAdaptedSecondQuantization.e</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">e(p, q, r, s) = E(p, q) * E(r, s) - δ(r, q) * E(p, s)</code></pre><p>Alias for the two electron singlet excitation operator. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/operators/singlet_excitation_operator.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.enable_color-Tuple{}" href="#SpinAdaptedSecondQuantization.enable_color-Tuple{}"><code>SpinAdaptedSecondQuantization.enable_color</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enable_color()</code></pre><p>Enables the coloring of MO-indices to indicate orbital space constraints. Color is enabled by default. The default coloring scheme is given by:</p><ul><li>GeneralOrbital: :nothing</li><li>OccupiedOrbital: :light_green</li><li>VirtualOrbital: :cyan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/index_spaces.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.enable_index_translation-Tuple{}" href="#SpinAdaptedSecondQuantization.enable_index_translation-Tuple{}"><code>SpinAdaptedSecondQuantization.enable_index_translation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enable_index_translation()</code></pre><p>Enables the translation of summation indices over occupied and virtual to be printed as ijkl... and abcd... respectively instead of pqrs...</p><p>By default translated indices lose their subspace coloring to reduce redundant information (unless the index is in an even stricter subspace which requires coloring nevertheless).</p><p>This is enabled by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/index_spaces.jl#L277-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.look_for_tensor_replacements-Tuple{SpinAdaptedSecondQuantization.Expression, Any}" href="#SpinAdaptedSecondQuantization.look_for_tensor_replacements-Tuple{SpinAdaptedSecondQuantization.Expression, Any}"><code>SpinAdaptedSecondQuantization.look_for_tensor_replacements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">look_for_tensor_replacements(ex::Expression, transformer)</code></pre><p>Looks for pairs of terms in <code>ex</code> that are equal up to a tensor transformation given by <code>transformer</code>. The most common use case is to recognize patterns such as <span>$L_{pqrs} = 2 g_{pqrs} - g_{psrq}$</span> where a convencience function to produce the relevant transformer provided (see <a href="#SpinAdaptedSecondQuantization.make_exchange_transformer-Tuple{Any, Any}"><code>make_exchange_transformer</code></a>).</p><pre><code class="language- hljs">DocTestSetup = quote
    using SpinAdaptedSecondQuantization
    h = ∑(real_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * electron(1, 2), 1:2)
    g = 1//2 * simplify(
        ∑(psym_tensor(&quot;g&quot;, 1:4...) * e(1:4...) * electron(1:4...), 1:4)
    )
    H = h + g + real_tensor(&quot;h_nuc&quot;)
end</code></pre><pre><code class="language-julia-repl hljs">julia&gt; E_HF = simplify_heavy(hf_expectation_value(H))
h_nuc
+ 2 ∑_i(h_ii)
+ 2 ∑_ij(g_iijj)
- ∑_ij(g_ijji)
julia&gt; look_for_tensor_replacements(E_HF, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))
h_nuc
+ 2 ∑_i(h_ii)
+ ∑_ij(L_iijj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/tensor_replacements.jl#L114-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.make_exchange_transformer-Tuple{Any, Any}" href="#SpinAdaptedSecondQuantization.make_exchange_transformer-Tuple{Any, Any}"><code>SpinAdaptedSecondQuantization.make_exchange_transformer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_exchange_transformer(name_from, name_to)</code></pre><p>Convenience function to make tensor transformer for use in <a href="#SpinAdaptedSecondQuantization.look_for_tensor_replacements-Tuple{SpinAdaptedSecondQuantization.Expression, Any}"><code>look_for_tensor_replacements</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/tensor_replacements.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.make_permutation_mappings-Tuple{Any}" href="#SpinAdaptedSecondQuantization.make_permutation_mappings-Tuple{Any}"><code>SpinAdaptedSecondQuantization.make_permutation_mappings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_permutation_mappings(index_groups)</code></pre><p>Convenience function to make mapping for all permutations of groups of indices. See <a href="#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a> and <a href="#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>desymmetrize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/desymmetrization.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.print_code-Tuple{SpinAdaptedSecondQuantization.Term, String, Any}" href="#SpinAdaptedSecondQuantization.print_code-Tuple{SpinAdaptedSecondQuantization.Term, String, Any}"><code>SpinAdaptedSecondQuantization.print_code</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Print term to numpy&#39;s einsum routine</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/code_generators/old.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.print_eT_code-Tuple{SpinAdaptedSecondQuantization.Term, Any, Any, Any}" href="#SpinAdaptedSecondQuantization.print_eT_code-Tuple{SpinAdaptedSecondQuantization.Term, Any, Any, Any}"><code>SpinAdaptedSecondQuantization.print_eT_code</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Used with https://github.com/alexancp/einsumpath-to-eT to generate Fortran subroutines for eT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/code_generators/old.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.print_eT_function_generator" href="#SpinAdaptedSecondQuantization.print_eT_function_generator"><code>SpinAdaptedSecondQuantization.print_eT_function_generator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>print<em>eT</em>function<em>generator(name, ex, symbol, indices, translation,                     [wf</em>type], [tensor<em>translation], [noinput</em>tensors], [outperms])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/code_generators/eT_code.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.print_julia_function" href="#SpinAdaptedSecondQuantization.print_julia_function"><code>SpinAdaptedSecondQuantization.print_julia_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>print<em>julia</em>function(name, ex, symbol, indices, translation,                     [tensor<em>translation], [explicit</em>tensor_blocks])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/code_generators/julia.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T&lt;:Number" href="#SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T&lt;:Number"><code>SpinAdaptedSecondQuantization.project_biorthogonal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project_biorthogonal(ex::Expression, template::Expression)</code></pre><p>This has the effect of projecting the expression <code>ex</code> on the biorthogonal bra state of the <code>template</code> expression.</p><p>For a singlet double excitation, the following will be equivalent:</p><pre><code class="nohighlight hljs">bra = (
        1//3 * E(1, 2) * E(3, 4) +
        1//6 * E(1, 4) * E(3, 2)
    )&#39; * occupied(2, 4) * virtual(1, 3)

result = hf_expectation_value(bra * ex)</code></pre><pre><code class="nohighlight hljs">ket = E(1, 2) * E(3, 4) * occupied(2, 4) * virtual(1, 3)
result = project_biorthogonal(act_on_ket(ex), ket)
result = symmetrize(result, make_permutation_mappings([(1, 2), (3, 4)]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/biorthogonal.jl#L13-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.set_color-Tuple{Int64, Any}" href="#SpinAdaptedSecondQuantization.set_color-Tuple{Int64, Any}"><code>SpinAdaptedSecondQuantization.set_color</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_color(S, color=default_color(S))</code></pre><p>Sets the color of a given orbital space to the specified color, or the default if none is given. Allowed colors are given by the <a href="https://github.com/JuliaLang/julia/blob/17cfb8e65ead377bf1b4598d8a9869144142c84e/base/util.jl#L5-L34">Base.text_colors</a> dict. This includes integers in the range 0-255 which the corresponding colors can be found in this table on <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit">Wikipedia</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/index_spaces.jl#L237-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.simplify-Tuple{SpinAdaptedSecondQuantization.Expression}" href="#SpinAdaptedSecondQuantization.simplify-Tuple{SpinAdaptedSecondQuantization.Expression}"><code>SpinAdaptedSecondQuantization.simplify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simplify(ex::Expression)</code></pre><p>Applies various simplification strategies to the given expression. The most important are:</p><ul><li>Remove Kronecker deltas when indices are summed over.</li><li>Perform various operations to try to lower the lexiographic ordering of the   each term including:<ul><li>Lowering indices showing up in a Kronecker delta to the lowest of the   indices in said delta.</li><li>Lowering summation indices to lowest available indices.</li><li>Reorder summation indices to lower the lexiographic ordering of the order   they show up within the term.</li><li>Bubble sort operators swaping neighbouring operators if:<ul><li>They commute</li><li>The swap would lower the terms lexiographic ordering.</li></ul></li></ul></li><li>Look for pairs of terms differing only in index constraints and scalar   prefactors, and tries to combine them.</li></ul><p><strong>Examples:</strong></p><p>Collapsing deltas:</p><pre><code class="language-julia-repl hljs">julia&gt; using SpinAdaptedSecondQuantization

julia&gt; ∑(real_tensor(&quot;h&quot;, 1, 2) * electron(1, 2) * δ(1, 2), [2])
∑_q(δ_pq h_pq)
julia&gt; simplify(ans)
h_pp</code></pre><p>Combining terms differing only by index constraints and scalars:</p><pre><code class="language-julia-repl hljs">julia&gt; real_tensor(&quot;h&quot;, 1, 2) * (occupied(1, 2) + occupied(1) * virtual(2))
h_ia
+ h_ij
julia&gt; simplify(ans)
h_ip</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ∑(real_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * electron(1, 2), [1, 2])
∑_pq(h_pq E_pq)
julia&gt; ans - ∑(real_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * electron(1) * occupied(2), [1, 2])
∑_pq(h_pq E_pq)
- ∑_pi(h_pi E_pi)
julia&gt; simplify(ans)
∑_pa(h_pa E_pa)</code></pre><p>Sorting commuting operators:</p><pre><code class="language-julia-repl hljs">julia&gt; E(3, 4) * E(1, 2) * electron(1:4...)
E_rs E_pq
julia&gt; simplify(ans) # not able to swap as commutator is not zero
E_rs E_pq
julia&gt; ans * occupied(2, 4) * virtual(1, 3)
E_bj E_ai
julia&gt; simplify(ans) # now able to swap
E_ai E_bj</code></pre><pre><code class="language-julia-repl hljs">julia&gt; E(3, 4) * E(5, 6) * E(1, 2) * electron(5, 6) * occupied(2, 4) * virtual(1, 3)
E_bj E_pq E_ai
julia&gt; simplify(ans) # Can not swap first and last because of non commuting between
E_bj E_pq E_ai
julia&gt; E(5, 6) * E(3, 4) * E(1, 2) * electron(5, 6) * occupied(2, 4) * virtual(1, 3)
E_pq E_bj E_ai
julia&gt; simplify(ans) # Can swap adjacent last two, but not first
E_pq E_ai E_bj</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L258-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.simplify_heavy" href="#SpinAdaptedSecondQuantization.simplify_heavy"><code>SpinAdaptedSecondQuantization.simplify_heavy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simplify_heavy(ex::Expression,
    [mapping=GeneralOrbital =&gt; (OccupiedOrbital, VirtualOrbital)])</code></pre><p>Similar to <a href="#SpinAdaptedSecondQuantization.simplify-Tuple{SpinAdaptedSecondQuantization.Expression}"><code>simplify</code></a>, but enabling a few extra simplification strategies that can be quite expensive, especially as the number of summation indices in a term grows large.</p><p>The most expensive step is to iterate over <em>every permutation</em> of the summation indices of each term in order to find the order that has the least lexiographic ordering, which naturally has a scaling of O(n!) where n is the larget number of summation indices in a single term. This is quite managable for &quot;small&quot; numbers of indices (less than ~8), but quickly becomes unfeasible.</p><div class="admonition is-info" id="Note-424cd6e243d75f30"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-424cd6e243d75f30" title="Permalink"></a></header><div class="admonition-body"><p>The iteration over permutations of summation indices happens after summation indices that show up in Kronecker deltas, so if your terms contain many Kronecker deltas this might yet be possible to run.</p></div></div><p>The optional <code>mapping</code> argument defaults to splitting terms with general indices into a term with the index being occupied plus a term where the index is virtual, then performing simplification when all terms are split and recombining terms according to the same splitting if possible. This often allows for a few additional cancellations to occur than using only <a href="#SpinAdaptedSecondQuantization.simplify-Tuple{SpinAdaptedSecondQuantization.Expression}"><code>simplify</code></a> If dealing with other index spaces, this splitting can be specified can be specified to be some other set of index spaces. See <a href="../internals/#SpinAdaptedSecondQuantization.split_indices-Tuple{SpinAdaptedSecondQuantization.Expression, Any}"><code>split_indices</code></a>.</p><p><strong>Examples:</strong></p><p>HF energy with full real orbital symmetry:</p><pre><code class="language-julia-repl hljs">julia&gt; using SpinAdaptedSecondQuantization

julia&gt; h = ∑(rsym_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * electron(1, 2), 1:2)
∑_pq(h_pq E_pq)
julia&gt; g = 1//2 * ∑(rsym_tensor(&quot;g&quot;, 1:4...) * e(1:4...) * electron(1:4...), 1:4)
1/2 ∑_pqrs(g_pqrs E_pq E_rs)
- 1/2 ∑_pqrs(δ_qr g_pqrs E_ps)
julia&gt; H = simplify(h + g + real_tensor(&quot;h_nuc&quot;));

julia&gt; E_HF = simplify(hf_expectation_value(H)) # Not nice
h_nuc
+ 2 ∑_i(h_ii)
+ 2 ∑_ij(g_iijj)
- ∑_pi(g_pipi)
+ ∑_ia(g_iaia)
julia&gt; simplify_heavy(E_HF) # Much nicer!
h_nuc
+ 2 ∑_i(h_ii)
+ 2 ∑_ij(g_iijj)
- ∑_ij(g_ijij)</code></pre><p>Simplification by combining terms differing by index constraints</p><pre><code class="language-julia-repl hljs">julia&gt; ∑(real_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * electron(1, 2), [1, 2])
∑_pq(h_pq E_pq)
julia&gt; ans - ∑(real_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * occupied(1, 2), [1, 2])
∑_pq(h_pq E_pq)
- ∑_ij(h_ij E_ij)
julia&gt; ans - ∑(real_tensor(&quot;h&quot;, 1, 2) * E(1, 2) * virtual(1, 2), [1, 2])
∑_pq(h_pq E_pq)
- ∑_ab(h_ab E_ab)
- ∑_ij(h_ij E_ij)
julia&gt; simplify(ans)
∑_pq(h_pq E_pq)
- ∑_ab(h_ab E_ab)
- ∑_ij(h_ij E_ij)
julia&gt; simplify_heavy(ans)
∑_ai(h_ai E_ai)
+ ∑_ia(h_ia E_ia)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/expression.jl#L423-L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number" href="#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>SpinAdaptedSecondQuantization.symmetrize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize(ex::Expression, mappings)</code></pre><p>Function to expand the expression <code>ex</code> including all permutations of indices given by <code>mappings</code>. This is common to use to expand all permuations among neighbouring pairs of indices, such as to compute <span>$P_{ijk}^{abc} \Omega_{ijk}^{abc}$</span>. For this specific purpose we provide the convenience function <a href="#SpinAdaptedSecondQuantization.make_permutation_mappings-Tuple{Any}"><code>make_permutation_mappings</code></a> which produces all permutations between groups of indices.</p><pre><code class="language- hljs">DocTestSetup = :(using SpinAdaptedSecondQuantization)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; x = real_tensor(&quot;t&quot;, 1, 2, 3, 4, 5, 6) *
           occupied(2, 4, 6) * virtual(1, 3, 5)
t_aibjck
julia&gt; symmetrize(x, make_permutation_mappings([(1, 2), (3, 4), (5, 6)]))
t_aibjck
+ t_aickbj
+ t_bjaick
+ t_bjckai
+ t_ckaibj
+ t_ckbjai</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/desymmetrization.jl#L78-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.δ-Tuple" href="#SpinAdaptedSecondQuantization.δ-Tuple"><code>SpinAdaptedSecondQuantization.δ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">δ(indices...)</code></pre><p>Unicode alias for <a href="#SpinAdaptedSecondQuantization.delta-Tuple"><code>delta</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/kronecker_delta.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpinAdaptedSecondQuantization.τ-Tuple{Any, Any}" href="#SpinAdaptedSecondQuantization.τ-Tuple{Any, Any}"><code>SpinAdaptedSecondQuantization.τ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">τ(p, q)</code></pre><p>Constructs an expression containing a single triplet excitation operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/2d9dfac04986ae675491221e3704207eb62a8d57/src/operators/triplet_excitation_operator.jl#L40-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ccsd_example/">« CCSD example</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 18 July 2025 19:57">Friday 18 July 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
