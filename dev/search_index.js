var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference/API","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Auto generated docs for all exported functions and types.","category":"page"},{"location":"reference/#Types","page":"Reference/API","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:type]\nFilter = t -> !(t <: GeneralOrbital)\nPrivate = false","category":"page"},{"location":"reference/#Functions","page":"Reference/API","title":"Functions","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:function]\nPrivate = false","category":"page"},{"location":"reference/#SpinAdaptedSecondQuantization.E-Tuple{Any, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.E","text":"E(p, q)\n\nConstructs an expression containing a single excitation operator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.act_on_ket-Tuple{O} where O<:SpinAdaptedSecondQuantization.Operator","page":"Reference/API","title":"SpinAdaptedSecondQuantization.act_on_ket","text":"act_on_ket(::Operator)\n\nAll typed extending Operator must overload this function. It should return the expression you end up with after acting the operator on a normal RHF ket.\n\nExample:\n\nE_p q HF = (2 δ_p q C(pOqO) + E_p q C(pVqO)) HF\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.delta-Tuple","page":"Reference/API","title":"SpinAdaptedSecondQuantization.delta","text":"delta(indices...)\n\nConstruct an expression consisting of a single Kronecker delta of the given indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.e-NTuple{4, Any}","page":"Reference/API","title":"SpinAdaptedSecondQuantization.e","text":"e(p, q, r, s) = E(p, q) * E(r, s) - δ(r, q) * E(p, s)\n\nAlias for the two electron singlet excitation operator. ```\n\n\n\n\n\n","category":"method"},{"location":"reference/#SpinAdaptedSecondQuantization.δ-Tuple","page":"Reference/API","title":"SpinAdaptedSecondQuantization.δ","text":"δ(indices...)\n\nUnicode alias for delta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrbitalSpaces","page":"Reference/API","title":"OrbitalSpaces","text":"","category":"section"},{"location":"reference/","page":"Reference/API","title":"Reference/API","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:type]\nFilter = t -> t <: GeneralOrbital\nPrivate = false","category":"page"},{"location":"reference/#SpinAdaptedSecondQuantization.GeneralOrbital","page":"Reference/API","title":"SpinAdaptedSecondQuantization.GeneralOrbital","text":"GeneralOrbital\n\nTop level supertype of all orbital spaces. Any orbital subspace is a subtype of this type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SpinAdaptedSecondQuantization.OccupiedOrbital","page":"Reference/API","title":"SpinAdaptedSecondQuantization.OccupiedOrbital","text":"OccupiedOrbital\n\nType representing all occupied orbitals.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SpinAdaptedSecondQuantization.VirtualOrbital","page":"Reference/API","title":"SpinAdaptedSecondQuantization.VirtualOrbital","text":"VirtualOrbital\n\nType representing all virtual orbitals.\n\n\n\n\n\n","category":"type"},{"location":"#SpinAdaptedSecondQuantization.jl","page":"Home","title":"SpinAdaptedSecondQuantization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpinAdaptedSecondQuantization.jl is a Julia package for doing symbolic second quantization mainly targeted at quantum chemistry methods, such as post Hartree-Fock methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the package, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"(v1.8) pkg> add https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia version 1.8 or higher is required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can then be loaded","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpinAdaptedSecondQuantization","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpinAdaptedSecondQuantization","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n  using SpinAdaptedSecondQuantization\n  SASQ.disable_color()\nend","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2) * occupied(2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E(1, 2) * virtual(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hartree-Fock energy expression:","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = ∑(rsym_tensor(\"h\", 1, 2) * E(1, 2), 1:2)\ng = simplify(∑(rsym_tensor(\"g\", 1:4...) * e(1:4...), 1:4))\nH = h + g\nE_hf = simplify_heavy(act_on_ket(H, 0))","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Auto generated docs for functions and types that are not exported. Mostly for development use.","category":"page"},{"location":"internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:type]\nPublic = false","category":"page"},{"location":"internals/#SpinAdaptedSecondQuantization.Constraints","page":"Internals","title":"SpinAdaptedSecondQuantization.Constraints","text":"Constraints = SortedDict{Int,Type}\n\nType alias for container of MO-Index constraints\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.KroneckerDelta","page":"Internals","title":"SpinAdaptedSecondQuantization.KroneckerDelta","text":"KroneckerDelta\n\nType representing a Kronecker delta of two or more MO-indices.\n\nnote: Note\nWhen constructing a KroneckerDelta it will return the integer 1 if the delta does not include two or more distinkt indices.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.Operator","text":"Operator\n\nAbstact operator type which all concrete operator types (i.e. Epq, a†p) must extend.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.SingletExcitationOperator","page":"Internals","title":"SpinAdaptedSecondQuantization.SingletExcitationOperator","text":"SingletExcitationOperator\n\nThe basic E_pq type operator.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SpinAdaptedSecondQuantization.Spin","page":"Internals","title":"SpinAdaptedSecondQuantization.Spin","text":"Spin\n\nEnum type to represent spin up (α) and down (β)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Functions","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [SpinAdaptedSecondQuantization]\nOrder = [:function]\nPublic = false","category":"page"},{"location":"internals/#Base.:==-Union{Tuple{B}, Tuple{A}, Tuple{A, B}} where {A<:SpinAdaptedSecondQuantization.Operator, B<:SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"Base.:==","text":"Base.:==(::Operator, ::Operator)\n\nThis has to be explicitly implemented for each operator type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.isless-Union{Tuple{B}, Tuple{A}, Tuple{A, B}} where {A<:SpinAdaptedSecondQuantization.Operator, B<:SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"Base.isless","text":"Base.isless(::Operator, ::Operator)\n\nAll operator types must implement how they should be sorted among themselves (isless(::O, ::O)) and with respect to all other operator types that it is expected to be used together with (isless(::A, ::B)).\n\nThe implementation for how it sorts among the same operator type should be implemented in the definition file for that operator type.\n\nThe implementation for how the type sorts compared to other operator types should be added to the src/operators/sorting.jl file. These should be dummy routines that simply return true or false, and do not depend on the contents of the operators.\n\nnote: Note\nOnly one order needs to be implemented, meaning if isless(::A, ::B) is implemented, there is no need to also implement isless(::B, ::A)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.print-Union{Tuple{O}, Tuple{IO, DataStructures.SortedDict{Int64, Type}, O}} where O<:SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"Base.print","text":"Base.print(::IO, ::Constraints, ::Operator)\n\nAll typed extending Operator must overload this function.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.compact_deltas-Tuple{Vector{SpinAdaptedSecondQuantization.KroneckerDelta}}","page":"Internals","title":"SpinAdaptedSecondQuantization.compact_deltas","text":"compact_deltas(deltas::Vector{KroneckerDelta})\n\nReturns a new reduced Vector{KroneckerDelta} where there exists only one delta per group of equal indices.\n\nExample:\n\nδ_pq δ_qr δ_st -> δ_pqr δst\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.disable_color-Tuple{}","page":"Internals","title":"SpinAdaptedSecondQuantization.disable_color","text":"disable_color()\n\nDisables the coloring of MO-indices to indicate orbital space constraints. This will make all constraints be printed explicitly which can make some terms a bit long to read. Color is enabled by default.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.enable_color-Tuple{}","page":"Internals","title":"SpinAdaptedSecondQuantization.enable_color","text":"enable_color()\n\nEnables the coloring of MO-indices to indicate orbital space constraints. Color is enabled by default. Currently the coloring scheme is given by:     GeneralOrbital: colorless     OccupiedOrbital: green     VirtualOrbital: blue\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.exchange_indices-Tuple{SpinAdaptedSecondQuantization.KroneckerDelta, Any}","page":"Internals","title":"SpinAdaptedSecondQuantization.exchange_indices","text":"exchange_indices(d::KroneckerDelta, mapping)\n\nReturns a new KroneckerDelta with indices exchanged according to the mapping\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.exchange_indices-Union{Tuple{O}, Tuple{O, Any}} where O<:SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.exchange_indices","text":"exchange_indices(::Operator, mapping)\n\nAll typed extending Operator must overload this function. It should return a new operator where all indices have been exchanged according to the mapping.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.get_all_indices-Tuple{O} where O<:SpinAdaptedSecondQuantization.Operator","page":"Internals","title":"SpinAdaptedSecondQuantization.get_all_indices","text":"get_all_indices(::Operator)\n\nAll typed extending Operator must overload this function. It should return an iteratable over all the MO-indices contained in the operator in order.\n\n\n\n\n\n","category":"method"},{"location":"internals/#SpinAdaptedSecondQuantization.reductive_commutator-Tuple{SpinAdaptedSecondQuantization.Operator, SpinAdaptedSecondQuantization.Operator}","page":"Internals","title":"SpinAdaptedSecondQuantization.reductive_commutator","text":"reductive_commutator(::Operator, ::Operator)\n\nDefines how operators commute. This will act as either a commutator or anticommutator depending on which reduces the rank of the resulting operators.\n\nReturns a Tuple{Int,Expression} which gives the type of commutator used and the resulting expression. The type is signaled by returning 1 or -1 as the first element of the tuple. This represents the sign change by commutation which is 1 for a normal commutator (A B = 0  AB == BA) and -1 for an anticommutator (A B_+ = 0  AB = -BA)\n\nThis should be implemented for all pairs of operators types that are expected to show up in the same expression. The implementations should be put in the src/operators/commutation_relations.jl file.\n\nnote: Note\nOnly one order needs to be implemented, meaning if reductive_commutator(::A, ::B) is implemented, there is no need to also implement reductive_commutator(::B, ::A)\n\n\n\n\n\n","category":"method"}]
}
