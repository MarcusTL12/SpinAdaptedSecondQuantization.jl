<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SpinAdaptedSecondQuantization.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SpinAdaptedSecondQuantization.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Basic-Structure"><span>Basic Structure</span></a></li><li class="toplevel"><a class="tocitem" href="#Orbital-Constraints"><span>Orbital Constraints</span></a></li><li><a class="tocitem" href="#Hartree-Fock-energy-expression"><span>Hartree-Fock energy expression</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference/API</a></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SpinAdaptedSecondQuantization.jl"><a class="docs-heading-anchor" href="#SpinAdaptedSecondQuantization.jl">SpinAdaptedSecondQuantization.jl</a><a id="SpinAdaptedSecondQuantization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SpinAdaptedSecondQuantization.jl" title="Permalink"></a></h1><p><a href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl">SpinAdaptedSecondQuantization.jl</a> is a Julia package for doing symbolic second quantization mainly targeted at quantum chemistry methods, such as post Hartree-Fock methods.</p><p>To install the package, run</p><pre><code class="language-julia hljs">(v1.8) pkg&gt; add https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl</code></pre><p>Julia version 1.8 or higher is required.</p><p>The package can then be loaded</p><pre><code class="language-julia hljs">using SpinAdaptedSecondQuantization</code></pre><h2 id="Basic-Structure"><a class="docs-heading-anchor" href="#Basic-Structure">Basic Structure</a><a id="Basic-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Structure" title="Permalink"></a></h2><p>The core type of the package is the <code>Expression</code> type. This contains an array of <code>Term</code> types. A term is a product that can contain a combination of various elements. These are:</p><ul><li>A <code>scalar</code> multiplier</li><li>An array of <code>operators</code></li><li>An array of <code>tensors</code></li><li>An array of <code>Kronecker deltas</code></li><li>An array of <code>summation indices</code></li><li>A dictionary of <code>orbital constraints</code></li></ul><h3 id="Orbital-Indices"><a class="docs-heading-anchor" href="#Orbital-Indices">Orbital Indices</a><a id="Orbital-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Orbital-Indices" title="Permalink"></a></h3><p>Most types will contain orbital indices. For convenience these are represented as integers, but they are purely symbolic. When printed, they will be given names according to the semi-standard names for general molecular orbital (MO) indices <code>pqrstuvw</code>. This means that index 1 will be printed as &#39;p&#39;, 2 as &#39;q&#39; and 8 as &#39;w&#39;. For indices larger than 8 the names wrap around and are numbered with subscripts so index 9 will be printed as &#39;p₁&#39; and index 78 as &#39;u₉&#39;.</p><h3 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h3><p>A small variety of operator types is supported, see (REF TO LIST) for full list.</p><p>A few examples are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">E_pq</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; E(1, 2) * E(3, 4)</code><code class="nohighlight hljs ansi" style="display:block;">E_pq E_rs</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(1, 2, 3, 4)</code><code class="nohighlight hljs ansi" style="display:block;">- δ_qr E_ps
+ E_pq E_rs</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fermion(1, α)</code><code class="nohighlight hljs ansi" style="display:block;">a⁻_pα</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fermiondag(2, β)</code><code class="nohighlight hljs ansi" style="display:block;">a†_qβ</code></pre><h3 id="Tensors"><a class="docs-heading-anchor" href="#Tensors">Tensors</a><a id="Tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Tensors" title="Permalink"></a></h3><p>The simplest tensor type is the <code>RealTensor</code> which has a name and an array of MO-indices.</p><p>Example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_tensor(&quot;h&quot;, 1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">h_pq</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_tensor(&quot;g&quot;, 1, 2, 3, 4)</code><code class="nohighlight hljs ansi" style="display:block;">g_pqrs</code></pre><p>Some other types of tensors are supported with various symmetries in the indices. See (REF TO LIST) for full list.</p><h3 id="Kronecker-Deltas"><a class="docs-heading-anchor" href="#Kronecker-Deltas">Kronecker Deltas</a><a id="Kronecker-Deltas-1"></a><a class="docs-heading-anchor-permalink" href="#Kronecker-Deltas" title="Permalink"></a></h3><p>Kronecker deltas constrain indices to be equal or else the term would be zero. They can have two or more indices each.</p><p>Example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; delta(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">δ_pq</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; δ(1, 2) # Unicode version equivalent to the one above</code><code class="nohighlight hljs ansi" style="display:block;">δ_pq</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 = δ(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">δ_pq</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d2 = δ(2, 3)</code><code class="nohighlight hljs ansi" style="display:block;">δ_qr</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 * d2 # Compacts delta expression since all are equal</code><code class="nohighlight hljs ansi" style="display:block;">δ_pqr</code></pre><h3 id="Summation-Indices"><a class="docs-heading-anchor" href="#Summation-Indices">Summation Indices</a><a id="Summation-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Summation-Indices" title="Permalink"></a></h3><p>A term can represent a sum over all values of a specific (or many) MO-indices.</p><p>Example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = summation(E(1, 2), [1])</code><code class="nohighlight hljs ansi" style="display:block;">∑_p(E_pq)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = ∑(E(1, 2), 1:2) # Unicode</code><code class="nohighlight hljs ansi" style="display:block;">∑_pq(E_pq)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a * b # Automatically renames summation indices to not collide</code><code class="nohighlight hljs ansi" style="display:block;">∑_prs(E_pq E_rs)</code></pre><h1 id="Orbital-Constraints"><a class="docs-heading-anchor" href="#Orbital-Constraints">Orbital Constraints</a><a id="Orbital-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Orbital-Constraints" title="Permalink"></a></h1><p>An important feature is the ability to tell a term whether an MO-index belongs to a particular subset of all orbitals, specifically whether it belongs to the occupied or virtual set.</p><p>Example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; occupied(1)</code><code class="nohighlight hljs ansi" style="display:block;">C(p∈O)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; virtual(2)</code><code class="nohighlight hljs ansi" style="display:block;">C(q∈V)</code></pre><p>here the constraints are printed explicitly as that is all that exists in the term, but if the index shows up other places in the term, the indices are colored to indicate the constraints instead:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = E(1, 2) * virtual(1) * occupied(2)</code><code class="nohighlight hljs ansi" style="display:block;">E_<span class="sgr36">p</span><span class="sgr92">q</span></code></pre><p>Where occupied orbitals are colored green and virtual are colored blue. If you would rather not have colored prints (printing to file, no color support in terminal, preferance, ...) you can easily turn this off:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; SpinAdaptedSecondQuantization.disable_color()</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a</code><code class="nohighlight hljs ansi" style="display:block;">E_pq C(p∈V, q∈O)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SASQ.enable_color() # Can use acronym SASQ instead of full module name</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a</code><code class="nohighlight hljs ansi" style="display:block;">E_<span class="sgr36">p</span><span class="sgr92">q</span></code></pre><p>Constraints will transfer to other indices through Kronecker deltas and will produce a zero-term if they are unsatisfiable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = δ(1, 2) * occupied(1) # Now q is also occupied</code><code class="nohighlight hljs ansi" style="display:block;">δ_<span class="sgr92">pq</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = δ(2, 3) * virtual(3)</code><code class="nohighlight hljs ansi" style="display:block;">δ_<span class="sgr36">qr</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a * b # gives 0 as they cannot be occupied and virtual</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><h2 id="Hartree-Fock-energy-expression"><a class="docs-heading-anchor" href="#Hartree-Fock-energy-expression">Hartree-Fock energy expression</a><a id="Hartree-Fock-energy-expression-1"></a><a class="docs-heading-anchor-permalink" href="#Hartree-Fock-energy-expression" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = ∑(rsym_tensor(&quot;h&quot;, 1, 2) * E(1, 2), 1:2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_pq(h_pq E_pq)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = simplify(∑(rsym_tensor(&quot;g&quot;, 1:4...) * e(1:4...), 1:4))</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_pqr(g_prqr E_pq)
+ ∑_pqrs(g_pqrs E_pq E_rs)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; H = h + g</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_pqr(g_prqr E_pq)
+ ∑_pq(h_pq E_pq)
+ ∑_pqrs(g_pqrs E_pq E_rs)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; E_hf = simplify_heavy(act_on_ket(H, 0))</code><code class="nohighlight hljs ansi" style="display:block;">4 ∑_<span class="sgr92">pq</span>(g_<span class="sgr92">ppqq</span>)
- 2 ∑_<span class="sgr92">pq</span>(g_<span class="sgr92">pqpq</span>)
+ 2 ∑_<span class="sgr92">p</span>(h_<span class="sgr92">pp</span>)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference/API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 29 March 2023 13:48">Wednesday 29 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
