<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CCSD example · SpinAdaptedSecondQuantization.jl</title><meta name="title" content="CCSD example · SpinAdaptedSecondQuantization.jl"/><meta property="og:title" content="CCSD example · SpinAdaptedSecondQuantization.jl"/><meta property="twitter:title" content="CCSD example · SpinAdaptedSecondQuantization.jl"/><meta name="description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><meta property="og:description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><meta property="twitter:description" content="Documentation for SpinAdaptedSecondQuantization.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpinAdaptedSecondQuantization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>CCSD example</a><ul class="internal"><li><a class="tocitem" href="#Hamiltonian"><span>Hamiltonian</span></a></li><li><a class="tocitem" href="#Cluster-Operator"><span>Cluster Operator</span></a></li><li><a class="tocitem" href="#Similrarity-transformed-Hamiltonian"><span>Similrarity transformed Hamiltonian</span></a></li><li><a class="tocitem" href="#Ground-State-Energy-Expression-and-Equations"><span>Ground State Energy Expression and Equations</span></a></li><li><a class="tocitem" href="#Jacobian-Transformation"><span>Jacobian Transformation</span></a></li><li><a class="tocitem" href="#One-electron-density-matrices"><span>One-electron density matrices</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference/API</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CCSD example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CCSD example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MarcusTL12/SpinAdaptedSecondQuantization.jl/blob/main/docs/src/ccsd_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Coupled-Cluster-Singles-and-Doubles-Example"><a class="docs-heading-anchor" href="#Coupled-Cluster-Singles-and-Doubles-Example">Coupled Cluster Singles and Doubles Example</a><a id="Coupled-Cluster-Singles-and-Doubles-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-Cluster-Singles-and-Doubles-Example" title="Permalink"></a></h1><p>Here is a detailed example of how to derive common expressions and equations for the closed shell CCSD method. This will also serve as a way of showcasing the various functionality of the package.</p><h2 id="Hamiltonian"><a class="docs-heading-anchor" href="#Hamiltonian">Hamiltonian</a><a id="Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian" title="Permalink"></a></h2><p>For the hamiltonian we will use the familiar expression for the non-relativistic electronic hamiltonian, however we will express it in terms of the fock matrix instead of the normal one-electron matrix</p><p><span>$F_{pq} = h_{pq} + \sum_{i}{\left(2 g_{pqii} - g_{piiq}\right)}$</span></p><p><span>$h_{pq} = F_{pq} - \sum_{i}{\left(2 g_{pqii} - g_{piiq}\right)}$</span></p><p>This is because every expression except the HF energy looks simpler expressed in terms of the fock matrix. In code we then define the hamiltonian as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SpinAdaptedSecondQuantization</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h = ∑((
               real_tensor(&quot;F&quot;, 1, 2) +
               ∑((-2 * psym_tensor(&quot;g&quot;, 1, 2, 3, 3) +
                   psym_tensor(&quot;g&quot;, 1, 3, 3, 2)) * occupied(3), [3])
           ) * E(1, 2) * electron(1, 2), 1:2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_pq(F_pq E_pq)
- 2 ∑_pqi(g_pqii E_pq)
+ ∑_pqi(g_piiq E_pq)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = 1//2 * simplify(
           ∑(psym_tensor(&quot;g&quot;, 1:4...) * e(1:4...) * electron(1:4...), 1:4)
       )</code><code class="nohighlight hljs ansi" style="display:block;">- 1/2 ∑_pqr(g_prrq E_pq)
+ 1/2 ∑_pqrs(g_pqrs E_pq E_rs)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; H = h + g</code><code class="nohighlight hljs ansi" style="display:block;">∑_pq(F_pq E_pq)
- 2 ∑_pqi(g_pqii E_pq)
- 1/2 ∑_pqr(g_prrq E_pq)
+ ∑_pqi(g_piiq E_pq)
+ 1/2 ∑_pqrs(g_pqrs E_pq E_rs)</code></pre><p>We omit the nuclear repulsion term and we do not assume any symmetry in our integrals apart from the particle exchange symmetry in the two electron integrals. We do this since we can then use the T1 transformed integrals allowing us to ignore the T1 operator when deriving equations.</p><p>We can derive the HF energy expression for the Hamiltonian in terms of the Fock matrix as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E_HF = simplify_heavy(hf_expectation_value(H))</code><code class="nohighlight hljs ansi" style="display:block;">2 ∑_i(F_ii)
- 2 ∑_ij(g_iijj)
+ ∑_ij(g_ijji)</code></pre><h2 id="Cluster-Operator"><a class="docs-heading-anchor" href="#Cluster-Operator">Cluster Operator</a><a id="Cluster-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-Operator" title="Permalink"></a></h2><p>The cluster operator we define then as only the T2 operator as the T1 amplitudes are included in the T1 transformed integrals.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T2 = 1//2 * ∑(psym_tensor(&quot;t&quot;, 1:4...) * E(1, 2) * E(3, 4) *
       occupied(2, 4) * virtual(1, 3), 1:4)</code><code class="nohighlight hljs ansi" style="display:block;">1/2 ∑_aibj(t_aibj E_ai E_bj)</code></pre><h2 id="Similrarity-transformed-Hamiltonian"><a class="docs-heading-anchor" href="#Similrarity-transformed-Hamiltonian">Similrarity transformed Hamiltonian</a><a id="Similrarity-transformed-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Similrarity-transformed-Hamiltonian" title="Permalink"></a></h2><p>A central operator in coupled cluster theory is the similarity transformed Hamiltonian operator</p><p><span>$\bar H = e^{-T} H e^T$</span></p><p>This is usually computed using the Baker-Campbell-Hausdorff (BCH) expansion</p><p><span>$e^{-B} A e^B = A + [A, B] + \frac12 [[A, B], B] + \frac{1}{3!} [[[A], B], B] + ...$</span></p><p>A nice feature of this expansion for the electronic hamiltionian and the cluster operator is that it truncates after the 4th order term (5 terms). This is because the 5th order expression is zero</p><p><span>$[[[[[H, E_{ai}], E_{bj}], E_{ck}], E_{dl}], E_{em}] = 0$</span></p><p>This means that we can explicitly compute the full similarity transformed Hamiltonian with no fear of missing any terms. We supply the function <code>bch(A, B, n)</code> which computes the BCH expansion to nth order.</p><div class="admonition is-info" id="Note-eb5fbcd5717aad11"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-eb5fbcd5717aad11" title="Permalink"></a></header><div class="admonition-body"><p>We also supply the functon <code>bch(A, [B1, B2, ...], n)</code> which is equivalent to <code>bch(A, B1 + B2 + ..., n)</code> when all of <code>B1, B2, ...</code> comute among each other, but is much faster as it avoids computing equivalent terms such as <span>$[[A, B_1], B_2]$</span> and <span>$[[A, B_2], B_1]$</span>. This can be especially useful for higher order coupled cluster methods such as CCSDT and beyond, as well as exotic methods such as QED-CC and NEO-CC.</p></div></div><p>In code this looks like</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Hbar = simplify(bch(H, T2, 4)); # Avoid printing as this is quite long</code></pre><h2 id="Ground-State-Energy-Expression-and-Equations"><a class="docs-heading-anchor" href="#Ground-State-Energy-Expression-and-Equations">Ground State Energy Expression and Equations</a><a id="Ground-State-Energy-Expression-and-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ground-State-Energy-Expression-and-Equations" title="Permalink"></a></h2><p>The coupled cluster ground state energy and equations are obtained by projecting the similarity constrained Schrödinger equation</p><p><span>$\bar H |\text{HF}\rangle = E |\text{HF}\rangle$</span></p><p>onto a set of bra states. The energy is obtained by projecting on the HF bra</p><p><span>$E_0 = \langle\text{HF}| \bar H |\text{HF}\rangle$</span></p><p>while the coupled cluster wave function is determined by projecting on a set of excited bra states determined from the cluster operator</p><p><span>$\langle\mu| \bar H |\text{HF}\rangle = 0$</span></p><p>In both cases we require the quantity <span>$\bar H |\text{HF}\rangle$</span> which we can explicitly compute by the function <code>act_on_ket(ex, [max_ops])</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Hbar_ket = simplify(act_on_ket(Hbar, 2)); # Avoid printing long expression</code></pre><p>Here we choose to throw away any terms with more than two operators as in CCSD we are never projecting on any bra that is more than doubly excited. This can speed up the projection and further operations by a bit.</p><h3 id="Energy"><a class="docs-heading-anchor" href="#Energy">Energy</a><a id="Energy-1"></a><a class="docs-heading-anchor-permalink" href="#Energy" title="Permalink"></a></h3><p>To obtain the energy expression we project the Hbar<em>ket on HF from the left. This can be nicely done using the `act</em>on<em>bra(ex, [max</em>ops])` function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E0 = simplify_heavy(act_on_bra(Hbar_ket))</code><code class="nohighlight hljs ansi" style="display:block;">2 ∑_i(F_ii)
- 2 ∑_ij(g_iijj)
+ ∑_ij(g_ijji)
+ 2 ∑_iajb(g_iajb t_aibj)
- ∑_iajb(g_iajb t_ajbi)</code></pre><p>Since the interesting part here is that which differs from HF, we can get the correlation energy as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; E_corr = E0 - E_HF</code><code class="nohighlight hljs ansi" style="display:block;">2 ∑_iajb(g_iajb t_aibj)
- ∑_iajb(g_iajb t_ajbi)</code></pre><p>Here we see a very common pattern; the 2 * coulomb - 1 * exchange pattern where we have terms that differ by a prefactor of <span>$-\frac12$</span> and an exchange of index 2 and 4 of a 4 index tensor, such as the two electron integrals or the T2 amplitudes. We usually define separate tensor names for these patterns  such as</p><p><span>$L_{pqrs} = 2 g_{pqrs} - g_{psrq}$</span></p><p>and</p><p><span>$u_{aibj} = 2 t_{aibj} - t_{ajbi}$</span></p><p>We provide a pair of functions to look for this pattern in expressions. firstly and mainly <a href="../reference/#SpinAdaptedSecondQuantization.look_for_tensor_replacements-Tuple{SpinAdaptedSecondQuantization.Expression, Any}"><code>look_for_tensor_replacements</code></a> function which is the actual engine that takes an expression and a tensor transformation function and looks for terms that are equal up to this transformation. We provide the utility function <a href="../reference/#SpinAdaptedSecondQuantization.make_exchange_transformer-Tuple{Any, Any}"><code>make_exchange_transformer</code></a> which produces a transformer that looks for the 2 * coulomb - 1 * exchange pattern. We can show this in action on the correlation energy looking for both the patterns mentioned above</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(E_corr, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">∑_iajb(L_iajb t_aibj)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(E_corr, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">∑_iajb(g_iajb u_aibj)</code></pre><h3 id="Omega-Equations"><a class="docs-heading-anchor" href="#Omega-Equations">Omega Equations</a><a id="Omega-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Omega-Equations" title="Permalink"></a></h3><h4 id="Biorthogonal-Bra"><a class="docs-heading-anchor" href="#Biorthogonal-Bra">Biorthogonal Bra</a><a id="Biorthogonal-Bra-1"></a><a class="docs-heading-anchor-permalink" href="#Biorthogonal-Bra" title="Permalink"></a></h4><p>For the singles equations we want to compute quantity</p><p><span>$\Omega_i^a = \bar{\left\langle_i^a\right|} \bar H |\text{HF}\rangle$</span></p><p>where the bra <span>$\bar{\left\langle_i^a\right|}$</span> is the biorthogonal bra state for the singly excited determinant</p><p><span>$\left|_i^a\right\rangle = E_{ai} |\text{HF}\rangle$</span></p><p>defined such that</p><p><span>$\left\langle\bar{_i^a}|_j^b\right\rangle = \delta_{ij} \delta_{ab}$</span></p><p>For a singly excited determinant we can explicitly express this biorthogonal bra simply as</p><p><span>$\bar{\left\langle_i^a\right|} = \frac12 \langle\text{HF}| E_{ia}$</span></p><p>As a quick example we can show this</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bra = 1//2 * E(2, 1) * occupied(2) * virtual(1)</code><code class="nohighlight hljs ansi" style="display:block;">1/2 E_ia</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket = E(3, 4) * occupied(4) * virtual(3)</code><code class="nohighlight hljs ansi" style="display:block;">E_ai</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hf_expectation_value(bra * ket)</code><code class="nohighlight hljs ansi" style="display:block;">δ_ab δ_ij</code></pre><p>However for higher excitations the biorthogonal bra states can not be as easily expressed explicitly. For doubly excited determinants we want a biorthornormal bra state <span>$\bar{\left\langle_{ij}^{ab}\right|}$</span> such that</p><p><span>$\left\langle\bar{_{ij}^{ab}}|_{kl}^{cd}\right\rangle = P_{ai,bj} \delta_{ik} \delta_{jl} \delta_{ac} \delta_{bd} = \delta_{ik} \delta_{jl} \delta_{ac} \delta_{bd} + \delta_{jk} \delta_{il} \delta_{bc} \delta_{ad}$</span></p><p>with the permutation operator <span>$P_{ai,bj}$</span> generating the equivalent permutations due to the particle symmetry in the doubly excited determinant</p><p><span>$\left|_{ij}^{ab}\right\rangle = \left|_{ji}^{ba}\right\rangle = E_{ai} E_{bj} |\text{HF}\rangle = E_{bj} E_{ai} |\text{HF}\rangle$</span></p><p>We can write the biorthogonal bra explicitly as</p><p><span>$\bar{\left\langle_{ij}^{ab}\right|} = \frac13 \left\langle_{ij}^{ab}\right| + \frac16 \left\langle_{ji}^{ab}\right| = \langle\text{HF}| \left(     \frac13 E_{jb} E_{ia} +     \frac16 E_{ib} E_{ja} \right)$</span></p><p>Which we can confirm using the code</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bra = (1//3 * E(4, 3) * E(2, 1) + 1//6 * E(2, 3) * E(4, 1)) *
           occupied(2, 4) * virtual(1, 3)</code><code class="nohighlight hljs ansi" style="display:block;">1/6 E_ib E_ja
+ 1/3 E_jb E_ia</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket = E(5, 6) * E(7, 8) * occupied(6, 8) * virtual(5, 7)</code><code class="nohighlight hljs ansi" style="display:block;">E_ai E_bj</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hf_expectation_value(bra * ket)</code><code class="nohighlight hljs ansi" style="display:block;">δ_ac δ_ik δ_bd δ_jl
+ δ_ad δ_il δ_bc δ_jk</code></pre><div class="admonition is-info" id="Note-ab42acdfdaf944c1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ab42acdfdaf944c1" title="Permalink"></a></header><div class="admonition-body"><p>For higher order excited determinants such as triples, quadruples, etc. it is, however, not possible to explicitly express a biorthogonal state that has the desired properties. This is related to the fact that the expression is zero</p><p><span>$P^{abc} E_{ai} E_{bj} E_{ck} = 0$</span></p><p>It is, however, still useful to be able to derive the expressions you would get if you project on a biorthogonal basis anyway, even if it is not expressible as a linear combination of excited determinants. For the triples for example, we can define two distinct expressions</p><p><span>$\Omega_{ijk}^{abc} = \left\langle\bar{_{ijk}^{abc}}\right| \bar H |\text{HF}\rangle$</span></p><p><span>$\tilde \Omega_{ijk}^{abc} = \left\langle_{ijk}^{abc}\right| \bar H |\text{HF}\rangle$</span></p><p>the latter of which is the quantity that &quot;actually exists&quot; as a projection onto a set of bra states which are expressible as excited determinants and represent the equations which are to be solved to obtain the coupled cluster wave function. The two <span>$\Omega$</span> expressions are related by a non invertible linear transformation</p><p><span>$\tilde \Omega_{ijk}^{abc} = \sum_{a&#39;i&#39;b&#39;j&#39;c&#39;k&#39;}{     S_{ijki&#39;j&#39;k&#39;}^{abca&#39;b&#39;c&#39;}     \Omega_{i&#39;j&#39;k&#39;}^{a&#39;b&#39;c&#39;} }$</span></p><p>We can then see that if one finds amplitudes such that the <span>$\Omega$</span> found by using the biorthogonal states they will also make the <span>$\tilde \Omega$</span> be zero, which is the condition we want to solve for. This is nice as we can safely &quot;pretend&quot; there exists a biorthogonal basis which produces much simpler expressions and are therefore more efficient to derive and numerically compute.</p></div></div><p>Since we do not want to (and often can not, see note above) make an explicit expression for a biorthogonal bra we provide the function <a href="../reference/#SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T&lt;:Number"><code>project_biorthogonal</code></a> which lets us insert Kronecker deltas according to the definition of the biorthogonality in addition to the <a href="../reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a> function to expand the permutations required by the biorthogonality. We can reproduce the same behaviour as for the biorthogonal doubles from above as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket = E(5, 6) * E(7, 8) * occupied(6, 8) * virtual(5, 7)</code><code class="nohighlight hljs ansi" style="display:block;">E_ai E_bj</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(ket, E(1, 2) * E(3, 4))</code><code class="nohighlight hljs ansi" style="display:block;">δ_ac δ_ik δ_bd δ_jl</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]))</code><code class="nohighlight hljs ansi" style="display:block;">δ_ac δ_ik δ_bd δ_jl
+ δ_ad δ_il δ_bc δ_jk</code></pre><p>Here we supplied the &quot;template&quot; ket <code>E(1, 2) * E(3, 4)</code> which is that we want to project on the biorthogonal bra of.</p><div class="admonition is-info" id="Note-d87a6ba16dfa6151"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d87a6ba16dfa6151" title="Permalink"></a></header><div class="admonition-body"><p>Usually one wants to evaluate projections using the <em>biorthonormal</em> bra which for doubles is defined as</p><p><span>$\tilde{\left\langle_{ij}^{ab}\right|} = \frac{1}{1 + \delta_{ai,bj}} \bar{\left\langle_{ij}^{ab}\right|}$</span></p><p>which removes the factor of 2 on the diagonal elements where <code>ai = bj</code>. This is usually done by numerically scaling the diagonal of the output by 0.5 as the expressions look nicer using the biorthogonal bra. Note that for higher order excitations there are more &quot;diagonals&quot; to think about.</p></div></div><h4 id="Singles-Equations"><a class="docs-heading-anchor" href="#Singles-Equations">Singles Equations</a><a id="Singles-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Singles-Equations" title="Permalink"></a></h4><p>We can use the <a href="../reference/#SpinAdaptedSecondQuantization.project_biorthogonal-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, SpinAdaptedSecondQuantization.Expression}} where T&lt;:Number"><code>project_biorthogonal</code></a> function to project <code>Hbar_ket</code> on the singles biorthogonal bra and get an expression for <span>$\Omega_i^a$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_ai = project_biorthogonal(Hbar_ket, E(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">F_ai
+ 2 ∑_jb(F_jb t_aibj)
- ∑_jb(F_jb t_ajbi)
+ 2 ∑_bjc(g_abjc t_bicj)
- ∑_bjc(g_abjc t_bjci)
- 2 ∑_jkb(g_jikb t_ajbk)
+ ∑_jkb(g_jikb t_akbj)</code></pre><p>Here we also see the 2 * coulomb - 1 * exchange pattern show up again, so we can simplify by.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_ai = look_for_tensor_replacements(omega_ai,
           make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">F_ai
+ ∑_jb(F_jb u_aibj)
+ ∑_bjc(g_abjc u_bicj)
- ∑_jkb(g_jikb u_ajbk)</code></pre><p>Which produces a nice simplified expression for the singes part of the CCSD equations.</p><h4 id="Doubles-Equations"><a class="docs-heading-anchor" href="#Doubles-Equations">Doubles Equations</a><a id="Doubles-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Doubles-Equations" title="Permalink"></a></h4><p>Here we want to derive the expression for the doubles <span>$\Omega$</span></p><p><span>$\Omega_{ij}^{ab} = \bar{\left\langle_{ij}^{ab}\right|} \bar H |\text{HF}\rangle$</span></p><p>Just like for the singles equations we project on a biorthogonal bra, though now using a doubly excited ket as the template, and we need to symmetrize to include the pertmutations caused by the particle symmetry of the biorthogonal bra.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(Hbar_ket, E(1, 2) * E(3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj = simplify_heavy(
           symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)])));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_u = look_for_tensor_replacements(omega_aibj,
           make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">g_aibj
+ ∑_c(F_ac t_bjci)
+ ∑_c(F_bc t_aicj)
- ∑_k(F_ki t_akbj)
- ∑_k(F_kj t_aibk)
+ ∑_cd(g_acbd t_cidj)
- ∑_ck(g_acki t_bjck)
- ∑_ck(g_ackj t_bkci)
- ∑_ck(g_bcki t_akcj)
- ∑_ck(g_bckj t_aick)
+ ∑_kl(g_kilj t_akbl)
+ ∑_kc(g_aikc u_bjck)
+ ∑_kc(g_bjkc u_aick)
+ ∑_kcld(g_kcld t_aicl t_bkdj)
+ ∑_kcld(g_kcld t_akbl t_cidj)
+ ∑_kcld(g_kcld t_akdj t_blci)
- ∑_kcld(g_kcld t_aibk u_cjdl)
- ∑_kcld(g_kcld t_aicj u_bkdl)
- ∑_kcld(g_kcld t_akbj u_cidl)
- ∑_kcld(g_kcld t_bjci u_akdl)
- ∑_kcld(g_kcld t_bjcl u_aidk)
+ ∑_kcld(g_kcld u_aick u_bjdl)</code></pre><p>Here we needed to use the (sometimes) expensive <a href="../reference/#SpinAdaptedSecondQuantization.simplify_heavy"><code>simplify_heavy</code></a> function to fully simplify, as well as recognizing the 2 * coulomb - 1 * exchange pattern for the T2 amplitudes. Now we have a correct and rather nice expression for the doubles equations, however, because of the particle symmetry of the bra that we introduced with the call to <a href="../reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a> some terms are equal after permuting the indices (a, i) &lt;-&gt; (b, j). Computing all of these redundant terms leads to a lot of unnecessary terms to code and compute, so it is much more efficient to only code the non-redundant ones, then symmetrize the final result numerically. To help with this, we provide the <a href="../reference/#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>desymmetrize</code></a> function which sort of acts like the reverse of <a href="../reference/#SpinAdaptedSecondQuantization.symmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>symmetrize</code></a>. We can call this function on our <span>$\Omega_{ij}^{ab}$</span> expression</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_r, omega_aibj_ss, omega_aibj_ns = desymmetrize(
           omega_aibj_u, make_permutation_mappings([(1, 2), (3, 4)])
       );</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_r</code><code class="nohighlight hljs ansi" style="display:block;">∑_c(F_ac t_bjci)
- ∑_k(F_ki t_akbj)
- ∑_ck(g_acki t_bjck)
- ∑_ck(g_ackj t_bkci)
+ ∑_kc(g_aikc u_bjck)
- ∑_kcld(g_kcld t_aibk u_cjdl)
- ∑_kcld(g_kcld t_aicj u_bkdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_ss</code><code class="nohighlight hljs ansi" style="display:block;">g_aibj
+ ∑_cd(g_acbd t_cidj)
+ ∑_kl(g_kilj t_akbl)
+ ∑_kcld(g_kcld t_akbl t_cidj)
+ ∑_kcld(g_kcld t_akdj t_blci)
+ ∑_kcld(g_kcld u_aick u_bjdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_ns</code><code class="nohighlight hljs ansi" style="display:block;">∑_kcld(g_kcld t_aicl t_bkdj)
- ∑_kcld(g_kcld t_bjcl u_aidk)</code></pre><p>The <a href="../reference/#SpinAdaptedSecondQuantization.desymmetrize-Union{Tuple{T}, Tuple{SpinAdaptedSecondQuantization.Expression{T}, Any}} where T&lt;:Number"><code>desymmetrize</code></a> function returns three expressions. The first <code>omega_aibj_r</code> contains the terms it found redundant permutations of elsewhere in the original expression. These needs to be symmetrized to obtain the correct expression. The second term <code>omega_aibj_ss</code> contains the &quot;self-symmetric&quot; terms. These are the terms which themselves carry the symmetry requested and can be evaluated as-is. The third and last term <code>omega_aibj_ns</code> are the &quot;non-symmetric&quot; terms. Interestingly, we have here gotten two terms in the non-symmetric expression, even though the result should be symmetric. Under closer inspection one can see that the two &quot;non-symmetric&quot; terms are indeed symmetric if one re-expands the <span>$u_{aidk}$</span> tensor in terms of <span>$t$</span>. To avoid having non-symmetric terms we can instead directly desymmetrize the omega before looking for coulomb - exchange symmetry.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_r, omega_aibj_ss, omega_aibj_ns = desymmetrize(
           omega_aibj, make_permutation_mappings([(1, 2), (3, 4)])
       );</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(omega_aibj_r, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">∑_c(F_ac t_bjci)
- ∑_k(F_ki t_akbj)
+ ∑_kc(L_aikc t_bjck)
- ∑_kc(g_aikc t_bkcj)
- ∑_ck(g_ackj t_bkci)
- ∑_kcld(L_kcld t_aibk t_cjdl)
- ∑_kcld(L_kcld t_aicj t_bkdl)
- ∑_kcld(L_kcld t_aick t_bldj)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(omega_aibj_ss, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">g_aibj
+ ∑_cd(g_acbd t_cidj)
+ ∑_kl(g_kilj t_akbl)
+ 2 ∑_kcld(L_kcld t_aick t_bjdl)
+ ∑_kcld(g_kcld t_akbl t_cidj)
+ ∑_kcld(g_kcld t_akci t_bldj)
+ ∑_kcld(g_kcld t_akdj t_blci)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; omega_aibj_ns</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>where we see that the non-symmetric part is indeed zero, but we have lost the ability to remove all prefactors. Counting total terms we can see that both strategies give 15 terms in total, so the cost should not be much different, but it can be nice to keep in mind. In any case to evaluate the full doubles omega one needs to symmetrize the redundant expression, and add the direct evaluation of the self-symmetric and apparent non-symmetric expression which we can write as</p><p><span>$\Omega_{ij}^{ab} = (\Omega_{\text{ss}})_{ij}^{ab} + (\Omega_{\text{ns}})_{ij}^{ab} + P_{ij}^{ab} (\Omega_{\text{s}})_{ij}^{ab}$</span></p><h2 id="Jacobian-Transformation"><a class="docs-heading-anchor" href="#Jacobian-Transformation">Jacobian Transformation</a><a id="Jacobian-Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Transformation" title="Permalink"></a></h2><p>The coupled cluster Jacobian is a central quantity for computing various properties of the coupled cluster wave function, such as density matrices and excitation energies. The Jacobian matrix <span>$A_{\mu\nu}$</span> is given by</p><p><span>$A_{\mu\nu} = \langle\mu| e^{-T} [H, \tau_{\nu}] e^T |\text{HF}\rangle$</span></p><p>though one is rarely interested in the full matrix, but rather to compute eigenvalues and solve linear systems. The matrix is usually huge and very structures (though not very sparse), so it is way more efficient to code a direct linear transformation. The Jacobian is not symmetric so one needs to derive both the right and left transformations given by</p><p><span>$\rho_\mu = \sum_{\nu}{A_{\mu\nu} c_\nu}$</span></p><p><span>$\sigma_\nu = \sum_{\mu}{b_\mu A_{\mu\nu}}$</span></p><p>We can quite nicely derive expressions for both of these transformations using the code.</p><h3 id="Right-transformation"><a class="docs-heading-anchor" href="#Right-transformation">Right transformation</a><a id="Right-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Right-transformation" title="Permalink"></a></h3><p>The transformed vector <span>$\rho_\mu$</span> can be split into singles and doubles block like</p><p><span>$\rho_{ai} = \sum_{\nu}{A_{ai,\nu} c_\nu}$</span></p><p><span>$\rho_{aibj} = \sum_{\nu}{A_{aibj,\nu} c_\nu}$</span></p><h4 id="Singles-block"><a class="docs-heading-anchor" href="#Singles-block">Singles block</a><a id="Singles-block-1"></a><a class="docs-heading-anchor-permalink" href="#Singles-block" title="Permalink"></a></h4><p>We then split the sum into blocks</p><p><span>$\rho_{ai} = \sum_{\nu}{A_{ai,\nu} c_\nu} = \sum_{ck}{A_{ai,ck} c_{ck}} + \sum_{ck \geq dl}{A_{ai,ckdl} c_{ckdl}}$</span></p><p>The singles sum is okay, but the triangular doubles sum <span>$ck \geq dl$</span> is not something we can express using the sums in the code, so we have to square it up.</p><p><span>$\sum_{ck \geq dl}{A_{ai,ckdl} c_{ckdl}} = \frac12 \sum_{ckdl}{(1 + \delta_{ck,dl}) A_{ai,ckdl} c_{ckdl}} = \frac12 \sum_{ckdl}{A_{ai,ckdl} \tilde c_{ckdl}}$</span></p><p>Here we have to add a factor of 2 on the diagonal of <span>$c_{ckdl}$</span> by defining the adjusted tensor</p><p><span>$\tilde c_{ckdl} = (1 + \delta_{ck,dl}) c_{ckdl}$</span></p><p>though we will not be using the <span>$\tilde c$</span> name in the derivation, but rather remembering that we have to numerically scale the diagonal of <span>$c_{ckdl}$</span> by 2 when coding the final expression.</p><p>We start by computing the projection</p><p><span>$\sum_{ck}{e^{-T} [H, E_{ck}] e^T |\text{HF}\rangle c_{ck}}$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(commutator(H, E(1, 2) * occupied(2) * virtual(1)));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(bch(ans, T2, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; proj_ai = simplify(act_on_ket(ans, 2));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; proj_ck = simplify(∑(ans * real_tensor(&quot;c&quot;, 1, 2), [1, 2]));</code></pre><p>This projection will also be useful when doing the doubles block. We also keep the <code>proj_ai</code> for the left transformation later. To get the singles block out we project on a biorthogonal singles bra</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_singles = project_biorthogonal(proj_ck, E(1, 2));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_singles = look_for_tensor_replacements(ρ_ai_singles,
           make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_singles = look_for_tensor_replacements(ρ_ai_singles,
           make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_singles</code><code class="nohighlight hljs ansi" style="display:block;">∑_b(F_ab c_bi)
- ∑_j(F_ji c_aj)
+ ∑_jb(L_aijb c_bj)
+ ∑_jbkc(L_jbkc c_bj u_aick)
- ∑_jbkc(c_aj g_jbkc u_bick)
- ∑_bjkc(c_bi g_jbkc u_ajck)</code></pre><p>where we get a very consise expression for the singles-singles transformation. Next we compute the projection</p><p><span>$\frac12 \sum_{ckdl}{e^{-T} [H, E_{ck} E_{dl}] e^T |\text{HF}\rangle c_{ckdl}}$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(commutator(H, E(1, 2) * E(3, 4) * occupied(2, 4) * virtual(1, 3)));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(bch(ans, T2, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; proj_aibj = simplify(act_on_ket(ans, 2));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; proj_ckdl = simplify(1//2 * ∑(ans * psym_tensor(&quot;c&quot;, 1:4...), 1:4));</code></pre><p>This will also be useful for the doubles block later and we also keep the proj_aibj for the left transformation. Now we project on the singles bra to get</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_doubles = project_biorthogonal(proj_ckdl, E(1, 2));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_doubles = look_for_tensor_replacements(ρ_ai_doubles,
           make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_doubles = look_for_tensor_replacements(ρ_ai_doubles,
           make_exchange_transformer(&quot;c&quot;, &quot;cu&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai_doubles</code><code class="nohighlight hljs ansi" style="display:block;">∑_jb(F_jb cu_aibj)
+ ∑_bjc(L_abjc c_bicj)
- ∑_jkb(L_jikb c_ajbk)</code></pre><p>Here we introduced another tensor pattern</p><p><span>$cu_{aibj} = 2 c_{aibj} - c_{ajbi}$</span></p><p>We can now combine the two parts of the <span>$\rho_{ai}$</span> block</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_ai = ρ_ai_singles + ρ_ai_doubles</code><code class="nohighlight hljs ansi" style="display:block;">∑_b(F_ab c_bi)
- ∑_j(F_ji c_aj)
+ ∑_jb(F_jb cu_aibj)
+ ∑_jb(L_aijb c_bj)
+ ∑_bjc(L_abjc c_bicj)
- ∑_jkb(L_jikb c_ajbk)
+ ∑_jbkc(L_jbkc c_bj u_aick)
- ∑_jbkc(c_aj g_jbkc u_bick)
- ∑_bjkc(c_bi g_jbkc u_ajck)</code></pre><h4 id="Doubles-block"><a class="docs-heading-anchor" href="#Doubles-block">Doubles block</a><a id="Doubles-block-1"></a><a class="docs-heading-anchor-permalink" href="#Doubles-block" title="Permalink"></a></h4><p>We again split the sum into singles and doubles, squareup and include the factor of 2 on the diagonal</p><p><span>$\rho_{aibj} = \sum_{\nu}{A_{aibj,\nu} c_\nu} = \sum_{ck}{A_{aibj,ck} c_{ck}} + \frac12 \sum_{ckdl}{A_{aibj,ckdl} \tilde c_{ckdl}}$</span></p><p>Here we can reuse the right projection from above, projecting on the biorthogonal doubles bra instead.</p><p>First the singles sum</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(proj_ck, E(1, 2) * E(3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(ans);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_singles_r, ρ_aibj_singles_ss, ρ_aibj_singles_ns =
           desymmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_singles_r</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_k(c_ak g_bjki)
+ ∑_c(c_ci g_acbj)
- ∑_kc(F_kc c_ak t_bjci)
- ∑_kc(F_kc c_ci t_akbj)
+ ∑_ckd(L_ackd c_dk t_bjci)
- ∑_klc(L_kilc c_cl t_akbj)
- ∑_kcd(c_ak g_bckd t_cjdi)
+ ∑_kcl(c_ak g_kcli t_bjcl)
+ ∑_kcl(c_ak g_kclj t_blci)
- ∑_cdk(c_ci g_adkc t_bjdk)
- ∑_cdk(c_ci g_bdkc t_akdj)
+ ∑_ckl(c_ci g_kjlc t_albk)
- ∑_klc(c_ak g_kilc u_bjcl)
+ ∑_ckd(c_ci g_ackd u_bjdk)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_singles_ss</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_singles_ns</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>Then the doubles sum</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(proj_ckdl, E(1, 2) * E(3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(ans);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_doubles_r, ρ_aibj_doubles_ss, ρ_aibj_doubles_ns =
           desymmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_doubles_r</code><code class="nohighlight hljs ansi" style="display:block;">∑_c(F_ac c_bjci)
- ∑_k(F_ki c_akbj)
+ ∑_kc(L_aikc c_bjck)
- ∑_kc(c_akci g_bjkc)
- ∑_kc(c_akcj g_bcki)
- ∑_kcld(L_kcld c_akdl t_bjci)
- ∑_kcld(L_kcld c_cidl t_akbj)
+ ∑_kcld(L_kcld c_aick u_bjdl)
+ ∑_kcdl(c_akci g_kdlc t_bjdl)
+ ∑_kcdl(c_akcj g_kdlc t_bldi)
- ∑_kcld(c_aibk g_kcld u_cjdl)
- ∑_ckld(c_aicj g_kcld u_bkdl)
- ∑_kcld(c_akci g_kcld u_bjdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_doubles_ss</code><code class="nohighlight hljs ansi" style="display:block;">∑_kl(c_akbl g_kilj)
+ ∑_cd(c_cidj g_acbd)
+ ∑_klcd(c_akbl g_kcld t_cidj)
+ ∑_cdkl(c_cidj g_kcld t_akbl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_doubles_ns</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>Combining singles and doubles</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_r = ρ_aibj_singles_r + ρ_aibj_doubles_r</code><code class="nohighlight hljs ansi" style="display:block;">∑_c(F_ac c_bjci)
- ∑_k(F_ki c_akbj)
- ∑_k(c_ak g_bjki)
+ ∑_c(c_ci g_acbj)
+ ∑_kc(L_aikc c_bjck)
- ∑_kc(c_akci g_bjkc)
- ∑_kc(c_akcj g_bcki)
- ∑_kc(F_kc c_ak t_bjci)
- ∑_kc(F_kc c_ci t_akbj)
+ ∑_ckd(L_ackd c_dk t_bjci)
- ∑_klc(L_kilc c_cl t_akbj)
- ∑_kcd(c_ak g_bckd t_cjdi)
+ ∑_kcl(c_ak g_kcli t_bjcl)
+ ∑_kcl(c_ak g_kclj t_blci)
- ∑_cdk(c_ci g_adkc t_bjdk)
- ∑_cdk(c_ci g_bdkc t_akdj)
+ ∑_ckl(c_ci g_kjlc t_albk)
- ∑_klc(c_ak g_kilc u_bjcl)
+ ∑_ckd(c_ci g_ackd u_bjdk)
- ∑_kcld(L_kcld c_akdl t_bjci)
- ∑_kcld(L_kcld c_cidl t_akbj)
+ ∑_kcld(L_kcld c_aick u_bjdl)
+ ∑_kcdl(c_akci g_kdlc t_bjdl)
+ ∑_kcdl(c_akcj g_kdlc t_bldi)
- ∑_kcld(c_aibk g_kcld u_cjdl)
- ∑_ckld(c_aicj g_kcld u_bkdl)
- ∑_kcld(c_akci g_kcld u_bjdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ_aibj_ss = ρ_aibj_doubles_ss</code><code class="nohighlight hljs ansi" style="display:block;">∑_kl(c_akbl g_kilj)
+ ∑_cd(c_cidj g_acbd)
+ ∑_klcd(c_akbl g_kcld t_cidj)
+ ∑_cdkl(c_cidj g_kcld t_akbl)</code></pre><p>which concludes the jacobian right transformation.</p><h3 id="Left-transformation"><a class="docs-heading-anchor" href="#Left-transformation">Left transformation</a><a id="Left-transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Left-transformation" title="Permalink"></a></h3><p>The procedure for the left transformation is very similar to the right transformation with some key differences. We can still split the transformed vector into singles and doubles blocks</p><p>The transformed vector <span>$\rho_\mu$</span> can be split into singles and doubles block like</p><p><span>$\sigma_{ai} = \sum_{\mu}{b_\mu A_{\mu,ai}}$</span></p><p><span>$\sigma_{aibj} = \sum_{\mu}{b_\mu A_{\mu,aibj}}$</span></p><h4 id="Singles-block-2"><a class="docs-heading-anchor" href="#Singles-block-2">Singles block</a><a class="docs-heading-anchor-permalink" href="#Singles-block-2" title="Permalink"></a></h4><p>We again further split the sum into singles and doubles parts</p><p><span>$\sigma_{ai} = \sum_{\mu}{b_\mu A_{\mu,ai}} = \sum_{ck}{b_{ck} A_{ck,ai}} + \frac12 \sum_{ckdl}{(1 + δ_{ck,dl}) b_{ckdl} A_{ckdl,ai}}$</span></p><p>though now we get a nice cancellation due to the fact that the jacobian is defined in terms of the <em>biorthonormal</em> bra, so we can define an adjusted jacobian</p><p><span>$\tilde A_{ckdl,\mu} = \frac{1}{1 + δ_{ck,dl}} A_{ckdl,\mu}$</span></p><p>defined in terms of the biorthogonal bra. The factors of 2 on the diagonal thus cancel and we are left with the much nicer expression</p><p><span>$\sigma_{ai} = \sum_{ck}{b_{ck} A_{ck,ai}} + \frac12 \sum_{ckdl}{b_{ckdl} \tilde A_{ckdl,ai}}$</span></p><p>where we do not have to scale either the input vector <span>$b$</span> or the output vector <span>$\sigma$</span> on the diagonals, contrary to the right transformation.</p><p>We can reuse the projection from above and can directly compute the singles projection</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(
           ∑(project_biorthogonal(proj_ai, E(5, 6)) * real_tensor(&quot;b&quot;, 5, 6), 5:6)
       );</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_ai_singles = ans</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_j(F_ij b_aj)
+ ∑_b(F_ba b_bi)
+ ∑_bj(L_iabj b_bj)
+ ∑_jbck(L_iajb b_ck u_bjck)
- ∑_jbkc(b_aj g_ibkc u_bjck)
- ∑_bjkc(b_bi g_jakc u_bjck)</code></pre><p>and similrarly for the doubles</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(proj_ai, E(5, 6) * E(7, 8)) * psym_tensor(&quot;b&quot;, 5:8...);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(∑(ans, 5:8)); # No need to symmetrize because of sum</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_ai_doubles = ans</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_jbk(b_ajbk g_ijbk)
+ ∑_bcj(b_bicj g_bacj)
- ∑_bjck(F_ib b_ajck t_bjck)
- ∑_jbck(F_ja b_bick t_bjck)
+ ∑_bcjdk(L_iabc b_bjdk t_cjdk)
- ∑_jkbcl(L_iajk b_bkcl t_bjcl)
- ∑_jbkcd(b_ajbk g_icbd t_cjdk)
+ ∑_jbkcl(b_ajbk g_iclj t_bkcl)
+ ∑_jbkcl(b_ajbk g_iclk t_blcj)
- ∑_bcjdk(b_bicj g_bdka t_cjdk)
- ∑_bcjdk(b_bicj g_cdka t_bkdj)
+ ∑_bcjkl(b_bicj g_kalj t_bkcl)
- ∑_jbklc(b_ajbk g_ijlc u_bkcl)
+ ∑_bcjkd(b_bicj g_bakd u_cjdk)</code></pre><div class="admonition is-info" id="Note-b345b6ca6137aa95"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b345b6ca6137aa95" title="Permalink"></a></header><div class="admonition-body"><p>Here we omited the call to <code>symmetrize</code> after <code>project_biorthogonal</code> because simplify can reorder the indices in the sum and achieve the same. This misses a factor of 2 which is compensated for by omiting the <code>1//2</code> in front of the sum.</p></div></div><p>And combined</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_ai = σ_ai_singles + σ_ai_doubles</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_j(F_ij b_aj)
+ ∑_b(F_ba b_bi)
+ ∑_bj(L_iabj b_bj)
- ∑_jbk(b_ajbk g_ijbk)
+ ∑_bcj(b_bicj g_bacj)
- ∑_bjck(F_ib b_ajck t_bjck)
- ∑_jbck(F_ja b_bick t_bjck)
+ ∑_jbck(L_iajb b_ck u_bjck)
- ∑_jbkc(b_aj g_ibkc u_bjck)
- ∑_bjkc(b_bi g_jakc u_bjck)
+ ∑_bcjdk(L_iabc b_bjdk t_cjdk)
- ∑_jkbcl(L_iajk b_bkcl t_bjcl)
- ∑_jbkcd(b_ajbk g_icbd t_cjdk)
+ ∑_jbkcl(b_ajbk g_iclj t_bkcl)
+ ∑_jbkcl(b_ajbk g_iclk t_blcj)
- ∑_bcjdk(b_bicj g_bdka t_cjdk)
- ∑_bcjdk(b_bicj g_cdka t_bkdj)
+ ∑_bcjkl(b_bicj g_kalj t_bkcl)
- ∑_jbklc(b_ajbk g_ijlc u_bkcl)
+ ∑_bcjkd(b_bicj g_bakd u_cjdk)</code></pre><h4 id="Doubles-block-2"><a class="docs-heading-anchor" href="#Doubles-block-2">Doubles block</a><a class="docs-heading-anchor-permalink" href="#Doubles-block-2" title="Permalink"></a></h4><p>The same cancellations hold as above, so the procedure is almost identical, but using the other ket projection.</p><p>Singles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(
           ∑(project_biorthogonal(proj_aibj, E(5, 6)) * real_tensor(&quot;b&quot;, 5, 6), 5:6)
       );</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_singles_r, σ_aibj_singles_ss, σ_aibj_singles_ns =
           desymmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_singles_r</code><code class="nohighlight hljs ansi" style="display:block;">2 F_ia b_bj
- F_ib b_aj
- ∑_k(L_iajk b_bk)
+ ∑_c(L_iacb b_cj)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_singles_ss</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_singles_ns</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>Doubles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(proj_aibj, E(5, 6) * E(7, 8)) * psym_tensor(&quot;b&quot;, 5:8...);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(∑(ans, 5:8)); # No need to symmetrize because of sum</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;g&quot;, &quot;L&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_doubles_r, σ_aibj_doubles_ss, σ_aibj_doubles_ns =
           desymmetrize(ans, make_permutation_mappings([(1, 2), (3, 4)]));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_doubles_r</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_k(F_ik b_akbj)
+ ∑_c(F_ca b_bjci)
+ ∑_ck(L_iack b_bjck)
- ∑_ck(b_ajck g_ibck)
- ∑_kc(b_akcj g_ikcb)
- ∑_ckdl(L_iajc b_bkdl t_ckdl)
- ∑_kcdl(L_iakb b_cjdl t_ckdl)
+ ∑_kcdl(L_iakc b_bjdl u_ckdl)
+ ∑_ckdl(b_ajck g_idlb t_ckdl)
+ ∑_kcdl(b_akcj g_idlb t_cldk)
- ∑_kcld(b_aibk g_jcld u_ckdl)
- ∑_ckld(b_aicj g_kbld u_ckdl)
- ∑_ckld(b_ajck g_ibld u_ckdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_doubles_ss</code><code class="nohighlight hljs ansi" style="display:block;">∑_kl(b_akbl g_ikjl)
+ ∑_cd(b_cidj g_cadb)
+ ∑_klcd(b_akbl g_icjd t_ckdl)
+ ∑_cdkl(b_cidj g_kalb t_ckdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_doubles_ns</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>Combined:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_r = σ_aibj_singles_r + σ_aibj_doubles_r</code><code class="nohighlight hljs ansi" style="display:block;">2 F_ia b_bj
- F_ib b_aj
- ∑_k(F_ik b_akbj)
+ ∑_c(F_ca b_bjci)
- ∑_k(L_iajk b_bk)
+ ∑_c(L_iacb b_cj)
+ ∑_ck(L_iack b_bjck)
- ∑_ck(b_ajck g_ibck)
- ∑_kc(b_akcj g_ikcb)
- ∑_ckdl(L_iajc b_bkdl t_ckdl)
- ∑_kcdl(L_iakb b_cjdl t_ckdl)
+ ∑_kcdl(L_iakc b_bjdl u_ckdl)
+ ∑_ckdl(b_ajck g_idlb t_ckdl)
+ ∑_kcdl(b_akcj g_idlb t_cldk)
- ∑_kcld(b_aibk g_jcld u_ckdl)
- ∑_ckld(b_aicj g_kbld u_ckdl)
- ∑_ckld(b_ajck g_ibld u_ckdl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ_aibj_ss = σ_aibj_doubles_ss</code><code class="nohighlight hljs ansi" style="display:block;">∑_kl(b_akbl g_ikjl)
+ ∑_cd(b_cidj g_cadb)
+ ∑_klcd(b_akbl g_icjd t_ckdl)
+ ∑_cdkl(b_cidj g_kalb t_ckdl)</code></pre><p>Which concludes the left transformation.</p><h2 id="One-electron-density-matrices"><a class="docs-heading-anchor" href="#One-electron-density-matrices">One-electron density matrices</a><a id="One-electron-density-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#One-electron-density-matrices" title="Permalink"></a></h2><p>One frequently wants the one-electron density matrix to get properties like dipole, quadrupole, magnetic moments, etc. both for a state and transition moments. In coupled cluster theory we have asymmetric density matrices which we can express as</p><p><span>$D_{pq} = \langle L| E_{pq} |R\rangle$</span></p><p>where the left and right states are given in general by</p><p><span>$\langle L| = \left(     L_0 \langle\text{HF}| +     \sum_{\mu}{L_\mu \langle\mu|} \right) e^{-T}$</span></p><p><span>$|R\rangle = e^T \left(     |\text{HF}\rangle R_0     +     \sum_{\nu}{|\nu\rangle R_\nu} \right)$</span></p><p>The left and right coefficient vectors can represent either ground excited states giving us the possibility to derive general expressions for ground and excited state as well as transition densities.</p><p>Firstly we will need the similarity transformed operator for all parts</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bch_Epq = bch(E(1, 2) * electron(1, 2), T2, 4)</code><code class="nohighlight hljs ansi" style="display:block;">E_pq
- 1/2 ∑_ajbk(δ_ij t_ajbk E_bk E_ap)
- 1/2 ∑_ajbk(δ_ik t_ajbk E_bp E_aj)
+ 1/2 ∑_bicj(δ_ab t_bicj E_cj E_pi)
+ 1/2 ∑_bicj(δ_ac t_bicj E_pj E_bi)
- 1/8 ∑_bjckdlem(δ_ij δ_ad t_bjck t_dlem E_ck E_bl E_em)
- 1/8 ∑_bjckdlem(δ_ij δ_ae t_bjck t_dlem E_ck E_dl E_bm)
- 1/8 ∑_bjckdlem(δ_ik δ_ad t_bjck t_dlem E_cl E_em E_bj)
- 1/8 ∑_bjckdlem(δ_ik δ_ae t_bjck t_dlem E_dl E_cm E_bj)
- 1/8 ∑_bjckdlem(δ_il δ_ab t_bjck t_dlem E_ck E_dj E_em)
- 1/8 ∑_bjckdlem(δ_il δ_ac t_bjck t_dlem E_dk E_em E_bj)
- 1/8 ∑_bjckdlem(δ_im δ_ab t_bjck t_dlem E_ck E_dl E_ej)
- 1/8 ∑_bjckdlem(δ_im δ_ac t_bjck t_dlem E_dl E_ek E_bj)</code></pre><h3 id="Ref-Ref-contributions"><a class="docs-heading-anchor" href="#Ref-Ref-contributions">Ref-Ref contributions</a><a id="Ref-Ref-contributions-1"></a><a class="docs-heading-anchor-permalink" href="#Ref-Ref-contributions" title="Permalink"></a></h3><p>The terms arising from the <span>$L_0$</span> and <span>$R_0$</span> (reference-reference) are quite straight forward to derive:</p><p><span>$D_{pq}^\text{ref-ref} = L_0 \langle\text{HF}| e^{-T} E_{pq} e^T |\text{HF}\rangle R_0$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_tensor(&quot;L0&quot;) * real_tensor(&quot;R0&quot;) * bch_Epq;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hf_expectation_value(ans)</code><code class="nohighlight hljs ansi" style="display:block;">2 δ_ij L0 R0</code></pre><p>where we see that only the HF density survives.</p><div class="admonition is-info" id="Note-7b9a4932d668e2e5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7b9a4932d668e2e5" title="Permalink"></a></header><div class="admonition-body"><p>Since we are not including T1 in the cluster operator we will initially miss many terms in the density coming from them. This is fine if the density is contracted with integrals that are T1 transformed, or one can include the T1 terms into the density by a similarity transform numerically which makes the expressions a bit nicer.</p></div></div><h3 id="\\mu-Ref-contributions"><a class="docs-heading-anchor" href="#\\mu-Ref-contributions"><span>$\mu$</span>-Ref contributions</a><a id="\\mu-Ref-contributions-1"></a><a class="docs-heading-anchor-permalink" href="#\\mu-Ref-contributions" title="Permalink"></a></h3><p>The terms arising from <span>$L_\mu$</span> and <span>$R_0$</span> are the only additional terms needed for the ground state density as <span>$R_\nu = 0$</span> for the ground state. We will omit the <span>$R_0$</span> in the derivation to reduce clutter. We can split the term into singles and doubles parts</p><p><span>$D_{pq}^{\mu\text{-ref}} = \sum_{\mu}{L_\mu \langle\mu|} e^{-T} E_{pq} e^T |\text{HF}\rangle \\= \sum_{ai}{L_{ai} \tilde{\langle_i^a|}} e^{-T} E_{pq} e^T |\text{HF}\rangle + \sum_{ai \geq bj}{L_{aibj} \tilde{\langle_{ij}^{ab}|}} e^{-T} E_{pq} e^T |\text{HF}\rangle$</span></p><p>in both cases we want the projection</p><p><span>$e^{-T} E_{pq} e^T |\text{HF}\rangle$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ref_ket = simplify_heavy(act_on_ket(bch_Epq, 2));</code></pre><p>Singles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ∑(project_biorthogonal(ref_ket, E(3, 4)) * real_tensor(&quot;L&quot;, 3, 4), 3:4);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(ans);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">L_ai
+ ∑_bj(L_bj u_aibj)</code></pre><p>For doubles we have the same cancellation as for the Jacobian left transformation</p><p><span>$\sum_{ai \geq bj}{L_{aibj} \tilde{\langle_{ij}^{ab}|}} e^{-T} E_{pq} e^T |\text{HF}\rangle = \frac12 \sum_{aibj}{L_{aibj} \bar{\langle_{ij}^{ab}|}} e^{-T} E_{pq} e^T |\text{HF}\rangle$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(ref_ket, E(3, 4) * E(5, 6));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ∑(ans * psym_tensor(&quot;L&quot;, 3:6...), 3:6);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_mu_ref = simplify_heavy(ans)</code><code class="nohighlight hljs ansi" style="display:block;">∑_icj(L_aicj t_bicj)
- ∑_abk(L_ajbk t_aibk)</code></pre><div class="admonition is-info" id="Note-315b92d47e5a7f58"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-315b92d47e5a7f58" title="Permalink"></a></header><div class="admonition-body"><p>Since the two terms in this expression have external indices with different constraints, it can be a bit confusing to look at. since these will be coded as separate blocks of the density matrix, it is usually advisable to extract the various blocks into their own expressions</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ij = D_mu_ref * occupied(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_abk(L_ajbk t_aibk)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ab = D_mu_ref * virtual(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_icj(L_aicj t_bicj)</code></pre><p>Alternatively one can disable translation of external indices to see the actual indices and constraints</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; disable_external_index_translation()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_mu_ref # Here we see index ₁ and ₂ as we specified in E(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_iaj(L_₁iaj t_₂iaj) C(₁∈v, ₂∈v)
- ∑_abi(L_a₂bi t_a₁bi) C(₁∈o, ₂∈o)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; enable_external_index_translation()</code></pre></div></div><h3 id="Ref-\\nu-contributions"><a class="docs-heading-anchor" href="#Ref-\\nu-contributions">Ref-<span>$\nu$</span> contributions</a><a id="Ref-\\nu-contributions-1"></a><a class="docs-heading-anchor-permalink" href="#Ref-\\nu-contributions" title="Permalink"></a></h3><p><span>$D_{pq}^{\text{ref-}\nu} = L_0 \sum_{\nu}{\langle\text{HF}| e^{-T} E_{pq} e^T |\nu\rangle R_\nu} \\= L_0 \sum_{ai}{\langle\text{HF}| e^{-T} E_{pq} e^T |_i^a\rangle R_{ai}} + L_0 \sum_{ai \geq bj}{     \langle\text{HF}| e^{-T} E_{pq} e^T |_{ij}^{ab}\rangle R_{aibj} }$</span></p><p>Singles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ∑(bch_Epq * E(3, 4) * occupied(4) * virtual(3) * real_tensor(&quot;R&quot;, 3, 4), 3:4);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; singles_ket = simplify(act_on_ket(ans, 2));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(act_on_bra(singles_ket))</code><code class="nohighlight hljs ansi" style="display:block;">2 R_ai</code></pre><p>For doubles we scale the <span>$R_{aibj}$</span> by 2 on the diagonal</p><p><span>$\sum_{ai \geq bj}{     \langle\text{HF}| e^{-T} E_{pq} e^T |_{ij}^{ab}\rangle R_{aibj} } = \frac12 \sum_{aibj}{     (1 + \delta_{ai,bj})     \langle\text{HF}| e^{-T} E_{pq} e^T |_{ij}^{ab}\rangle R_{aibj} } = \frac12 \sum_{aibj}{     \langle\text{HF}| e^{-T} E_{pq} e^T |_{ij}^{ab}\rangle \tilde R_{aibj} }$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bch_Epq * E(3, 4) * E(5, 6) * occupied(4, 6) * virtual(3, 5);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(1//2 * ∑(ans * psym_tensor(&quot;R&quot;, 3:6...), 3:6));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; doubles_ket = simplify(act_on_ket(ans, 2));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(act_on_bra(doubles_ket))</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><h3 id="\\mu-\\nu-contributions"><a class="docs-heading-anchor" href="#\\mu-\\nu-contributions"><span>$\mu$</span>-<span>$\nu$</span> contributions</a><a id="\\mu-\\nu-contributions-1"></a><a class="docs-heading-anchor-permalink" href="#\\mu-\\nu-contributions" title="Permalink"></a></h3><p><span>$D_{pq}^{\mu\text{-}\nu} = \sum_{\mu\nu}{     L_\mu \langle\mu| e^{-T} E_{pq} e^T |\nu\rangle R_\nu } \\= \sum_{aick}{     L_{ai} \tilde{\langle_i^a|} e^{-T} E_{pq} e^T |_k^c\rangle R_{ck} } \\+ \sum_{aibjck}{     L_{aibj} \tilde{\langle_{ij}^{ab}|} e^{-T} E_{pq} e^T |_k^c\rangle R_{ck} } \\+ \sum_{aickdl}{     L_{ai} \tilde{\langle_i^a|} e^{-T} E_{pq} e^T |_{kl}^{cd}\rangle R_{ckdl} } \\+ \sum_{aibjckdl}{     L_{aibj} \tilde{\langle_{ij}^{ab}|} e^{-T} E_{pq} e^T     |_{kl}^{cd}\rangle R_{ckdl} }$</span></p><p>Singles-Singles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(singles_ket, E(3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(∑(ans * real_tensor(&quot;L&quot;, 3, 4), 3:4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ss = ans</code><code class="nohighlight hljs ansi" style="display:block;">∑_i(L_ai R_bi)
- ∑_a(L_aj R_ai)
+ 2 ∑_ak(δ_ij L_ak R_ak)</code></pre><p>Doubles-Singles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(singles_ket, E(3, 4) * E(5, 6));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(∑(ans * psym_tensor(&quot;L&quot;, 3:6...), 3:6));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;t&quot;, &quot;u&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ds = ans</code><code class="nohighlight hljs ansi" style="display:block;">∑_bj(L_aibj R_bj)
- ∑_bjck(L_bjck R_aj t_bick)
- ∑_bjck(L_bjck R_bi t_ajck)
+ ∑_bjck(L_bjck R_bj u_aick)</code></pre><p>Singles-Doubles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(doubles_ket, E(3, 4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify(∑(ans * real_tensor(&quot;L&quot;, 3, 4), 3:4));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; look_for_tensor_replacements(ans, make_exchange_transformer(&quot;R&quot;, &quot;Ru&quot;));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_sd = ans</code><code class="nohighlight hljs ansi" style="display:block;">∑_bj(L_bj Ru_aibj)</code></pre><p>Doubles-Doubles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; project_biorthogonal(doubles_ket, E(3, 4) * E(5, 6));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; simplify_heavy(∑(ans * psym_tensor(&quot;L&quot;, 3:6...), 3:6));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_dd = ans</code><code class="nohighlight hljs ansi" style="display:block;">∑_icj(L_aicj R_bicj)
- ∑_abk(L_ajbk R_aibk)
+ ∑_akbl(δ_ij L_akbl R_akbl)</code></pre><p>Combining and separating into blocks:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = D_ss + D_sd + D_ds + D_dd</code><code class="nohighlight hljs ansi" style="display:block;">∑_i(L_ai R_bi)
- ∑_a(L_aj R_ai)
+ ∑_bj(L_aibj R_bj)
+ ∑_bj(L_bj Ru_aibj)
+ ∑_icj(L_aicj R_bicj)
- ∑_abk(L_ajbk R_aibk)
- ∑_bjck(L_bjck R_aj t_bick)
- ∑_bjck(L_bjck R_bi t_ajck)
+ ∑_bjck(L_bjck R_bj u_aick)
+ 2 ∑_ak(δ_ij L_ak R_ak)
+ ∑_akbl(δ_ij L_akbl R_akbl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ij = D * occupied(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">- ∑_a(L_aj R_ai)
- ∑_abk(L_ajbk R_aibk)
+ 2 ∑_ak(δ_ij L_ak R_ak)
+ ∑_akbl(δ_ij L_akbl R_akbl)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ia = D * occupied(1) * virtual(2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_bj(L_bj Ru_aibj)
- ∑_bjck(L_bjck R_aj t_bick)
- ∑_bjck(L_bjck R_bi t_ajck)
+ ∑_bjck(L_bjck R_bj u_aick)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ai = D * occupied(2) * virtual(1)</code><code class="nohighlight hljs ansi" style="display:block;">∑_bj(L_aibj R_bj)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D_ab = D * virtual(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">∑_i(L_ai R_bi)
+ ∑_icj(L_aicj R_bicj)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference/API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 19 July 2025 15:42">Saturday 19 July 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
